891. 子序列宽度之和

一个序列的 宽度 定义为该序列中最大元素和最小元素的差值。

给你一个整数数组 nums ，返回 nums 的所有非空 子序列 的 宽度之和 。由于答案可能非常大，请返回对 109 + 7 取余 后的结果。

子序列 定义为从一个数组里删除一些（或者不删除）元素，但不改变剩下元素的顺序得到的数组。例如，[3,6,2,7] 就是数组 [0,3,1,6,2,2,7] 的一个子序列。

 

示例 1：

输入：nums = [2,1,3]
输出：6
解释：子序列为 [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3] 。
相应的宽度是 0, 0, 0, 1, 1, 2, 2 。
宽度之和是 6 。

```js
var sumSubseqWidths = function (nums) {
    /* 
    1. 原问题：数组中所有子序列最大元素和最小元素差值之和
     转化：相当于求解 每个数字作为子序列最大值的贡献 - 作为子序列最小值的贡献 的和
     如果nums[i]在cnt1个子序列中作为最大值、在cnt2个子序列中作为最小值，
     那么，最终答案就等于 ∑(0~i) nums[i]*(cnt2-cnt1)

    2. 接下来，开始计算nums[i]在多少个序列中作为最大值和最小值
     nums 中以nums[i]结尾的子序列有多少个？
     因为前面0~i-1共i个数字，组成子序列时，每个数字可选可不选，所以共有2**i个
     以nums[i]开头的子序列有多少个？
     同理，nums[i]后面有n-1-i个数字，有2**(n-1-i)个
     如果nums升序排序，上面两个问题的答案会有什么特殊含义
     以nums[i]结尾的子序列有2**i个，由于nums升序排序，所以nums[i]是这些子序列中的最大值
     以nums[i]开头的子序列有2**(n-1-i)个，同样因为nums升序排序，那么nums[i]是这些子序列的最小值
     所以，得到nums[i]在2**i个序列中作为最大值，在2**(n-1-i)个序列中作为最小值
    至此，问题分析完毕
    */
    let n = nums.length, M = 1e9 + 7
    nums.sort((a, b) => a - b)
    let pow2 = [1]
    for (let i = 1; i < n; i++) pow2[i] = pow2[i - 1] * 2 % M

    let res = 0
    for (let i = 0; i < n; i++) {
        let cnt = (pow2[i] - pow2[n - 1 - i]) * nums[i] % M
        res = (res + cnt) % M
    }
    return res
};




class CountIntervals {
  private readonly tree = new SegmentTree(1e9 + 10)

  add(left, right): void {
    this.tree.update(left, right, true)
  }

  count() {
    return this.tree.queryAll()
  }
}


class Node {
  left!: Node
  right!: Node
  isLazy = false
  lazyValue = 0
  value = 0
}

class SegmentTree {
  private readonly root: Node = new Node()
  private readonly size

  constructor(size) {
    this.size = size
  }

  update(left, right, delta: boolean): void {
    this._update(left, right, 0, this.size, this.root, delta)
  }

  query(left, right) {
    return this._query(left, right, 0, this.size, this.root)
  }

  queryAll() {
    return this.root.value
  }

  private _update(
    L,
    R,
    l,
    r,
    root: Node,
    delta: boolean
  ): void {
    if (L <= l && r <= R) {
      root.value = r - l + 1
      root.lazyValue = 1
      root.isLazy = true
      return
    }

    const mid = Math.floor((l + r) / 2)
    this.pushDown(root, l, r, mid)
    if (L <= mid) this._update(L, R, l, mid, root.left, delta)
    if (mid < R) this._update(L, R, mid + 1, r, root.right, delta)
    this.pushUp(root)
  }

  private _query(L, R, l, r, root: Node) {
    if (L <= l && r <= R) {
      return root.value
    }

    let res = 0
    const mid = Math.floor((l + r) / 2)
    this.pushDown(root, l, r, mid)
    if (L <= mid) res += this._query(L, R, l, mid, root.left)
    if (mid < R) res += this._query(L, R, mid + 1, r, root.right)
    return res
  }

  private pushDown(root: Node, l, r, mid): void {
    !root.left && (root.left = new Node())
    !root.right && (root.right = new Node())
    if (root.isLazy) {
      root.left.isLazy = true
      root.right.isLazy = true
      root.left.lazyValue = root.lazyValue
      root.right.lazyValue = root.lazyValue
      root.left.value = mid - l + 1
      root.right.value = r - mid

      root.isLazy = false
      root.lazyValue = 0
    }
  }

  private pushUp(root: Node): void {
    root.value = root.left.value + root.right.value
  }
}