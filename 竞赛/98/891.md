891. 子序列宽度之和

一个序列的 宽度 定义为该序列中最大元素和最小元素的差值。

给你一个整数数组 nums ，返回 nums 的所有非空 子序列 的 宽度之和 。由于答案可能非常大，请返回对 109 + 7 取余 后的结果。

子序列 定义为从一个数组里删除一些（或者不删除）元素，但不改变剩下元素的顺序得到的数组。例如，[3,6,2,7] 就是数组 [0,3,1,6,2,2,7] 的一个子序列。

 

示例 1：

输入：nums = [2,1,3]
输出：6
解释：子序列为 [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3] 。
相应的宽度是 0, 0, 0, 1, 1, 2, 2 。
宽度之和是 6 。

```js
var sumSubseqWidths = function (nums) {
    /* 
    1. 原问题：数组中所有子序列最大元素和最小元素差值之和
     转化：相当于求解 每个数字作为子序列最大值的贡献 - 作为子序列最小值的贡献 的和
     如果nums[i]在cnt1个子序列中作为最大值、在cnt2个子序列中作为最小值，
     那么，最终答案就等于 ∑(0~i) nums[i]*(cnt2-cnt1)

    2. 接下来，开始计算nums[i]在多少个序列中作为最大值和最小值
     nums 中以nums[i]结尾的子序列有多少个？
     因为前面0~i-1共i个数字，组成子序列时，每个数字可选可不选，所以共有2**i个
     以nums[i]开头的子序列有多少个？
     同理，nums[i]后面有n-1-i个数字，有2**(n-1-i)个
     如果nums升序排序，上面两个问题的答案会有什么特殊含义
     以nums[i]结尾的子序列有2**i个，由于nums升序排序，所以nums[i]是这些子序列中的最大值
     以nums[i]开头的子序列有2**(n-1-i)个，同样因为nums升序排序，那么nums[i]是这些子序列的最小值
     所以，得到nums[i]在2**i个序列中作为最大值，在2**(n-1-i)个序列中作为最小值
    至此，问题分析完毕
    */
    let n = nums.length, M = 1e9 + 7
    nums.sort((a, b) => a - b)
    let pow2 = [1]
    for (let i = 1; i < n; i++) pow2[i] = pow2[i - 1] * 2 % M

    let res = 0
    for (let i = 0; i < n; i++) {
        let cnt = (pow2[i] - pow2[n - 1 - i]) * nums[i] % M
        res = (res + cnt) % M
    }
    return res
};

```