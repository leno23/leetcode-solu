857. 雇佣 K 名工人的最低成本

有 n 名工人。 给定两个数组 quality 和 wage ，其中，quality[i] 表示第 i 名工人的工作质量，其最低期望工资为 wage[i] 。

现在我们想雇佣 k 名工人组成一个工资组。在雇佣 一组 k 名工人时，我们必须按照下述规则向他们支付工资：

对工资组中的每名工人，应当按其工作质量与同组其他工人的工作质量的比例来支付工资。
工资组中的每名工人至少应当得到他们的最低期望工资。
给定整数 k ，返回 组成满足上述条件的付费群体所需的最小金额 。在实际答案的 10-5 以内的答案将被接受。。

示例 1：

输入： quality = [10,20,5], wage = [70,50,30], k = 2
输出： 105.00000
解释： 我们向 0 号工人支付 70，向 2 号工人支付 35。

```js
/**
 * @param {number[]} quality
 * @param {number[]} wage
 * @param {number} k
 * @return {number}
 */
var mincostToHireWorkers = function (quality, wage, k) {
    // 每个工人都有自己期望的价性比，雇佣K个工人的时候要满足每个人的实际价性比不低于他的期望，
    // 即需要按照K个工人中的最高期望价性比给这K个人开工资。
    const n = quality.length
    const ds = []
    for (let i = 0; i < n; i++) ds.push([wage[i] / quality[i], quality[i]])
    // 给工人的期望价性比从小到大排序，因为给每个工人支付工资之后，需要他们各自的价格质量比大于期望的价格质量比，
    // 那么，可以将所有工人的价格质量比从小到大排序后，从第一个工人开始，依次选择k个工人，
    // 直到第k个，这样一来，给他们支付的工资就是 他们的工作质量之和*第k个工人的价格质量比(也就是k个工人中最大的，是的他们的价性比都高于期望)
    // 满足条件之后，如何使得支付工资最小呢？ 此时就需要让k个工人的工作质量之和最小，也就是我们需要在计算过程中，维护k个最小的工人质量
    // 那么，我们就可以使用大根堆进行维护，选择工人过程中，将当前工人的工作质量放到大根堆中，当放入k个工人之后，假设当前是第x个工人
    // 我们可以计算一下前x个工人的最低工资；下一轮继续放入工人时，如果放入第y个工人之后，大根堆中元素数量超过k，则弹出一个最大工作质量的工人
    // 再次计算前y名工人的最低工资，和之前的结果对比，取较小值，就这样依次遍历过每个工人之后，最终得到的工资就是n名工人选择k个工人同时满足
    // 他们各自的价格质量比情况下的最小值
    ds.sort((a, b) => a[0] - b[0])
    const q = new MaxPriorityQueue()
    let ans = Infinity, tot = 0
    for (let i = 0; i < n; i++) {
        const cur = ds[i][1]
        tot += cur
        q.enqueue(cur)
        // 大根堆维护k个最低的工人的工作质量
        if (q.size() > k) tot -= q.dequeue().element
        // 前i个工人的最低工资为，每个工人的质量*最高的价性比
        if (q.size() == k) ans = Math.min(ans, tot * ds[i][0])
    }
    return ans

};
```
