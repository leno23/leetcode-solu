132. 分割回文串 II

给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文。

返回符合要求的 最少分割次数 。

示例 1：

输入：s = "aab"
输出：1
解释：只需一次分割就可将 s 分割成 ["aa","b"] 这样两个回文子串。

```js
/**
 * @param {string} s
 * @return {number}
 */
var minCut = function (s) {
  // 动态规划
  // 如果定义dp[i]表示s中前i个字符的最少分隔回文串的数目
  // 假设 字符串s中从第j个到字符结尾 为回文串,s的长度为n
  // 那么，有 dp[n] = dp[j-1] + 1
  // 也就是 前n个字符的最小分隔回文串的数目 = 前j-1个字符的最小分隔回文串的数目 + 最后一个回文串

  // 知道了这些之后，我们发现如果我们可以枚举每个位置结尾可能产生的回文串，就可以将求解当前字符串的问题
  // 转化成一个求前面部分字符串的 最小分隔回文串数目的问题

  // ind[i] 记录前i个字符，可以与结尾形成回文串的字符位置
  // 例如 a a a b 中
  // ind[1] = [0] 表示前1个字符，也就是a中 下标0到结尾可以组成一个回文串 a
  // ind[2] = [0,1] 表示前2个字符，也就是a a中 下标0和下标1到结尾可以组成一个回文串 a aa
  // ind[3] = [0,1,2] 表示前3个字符，也就是a中 下标0 和 下标1 和 下标2 到结尾可以组成一个回文串 a aa aaa
  // ind[4] = [3] 表示前4个字符，也就是aaab中 下标3到结尾可以组成一个回文串b

  // 提取字符串s中,前i个字符中 哪些位置可以和结尾形成回文串
  const extract = (s, i, j, ind) => {
    while (i >= 0 && s[i] == s[j]) {
      // 每一次首位相等，相当于一个新的回文串，需要记录下来
      // 下标i~j是一个回文串，是前j+1个字符的结尾
      ind[j + 1].push(i)
      i--, j++
    }
  }
  let n = s.length,
    ind = Array(n + 1)
      .fill()
      .map(() => [])
  for (let i = 0; i <= n; i++) ind[i] = []

  for (let i = 0; i < n; i++) {
    // 提取以i或者i/i+1 为中心的所有回文子串的位置信息
    extract(s, i, i, ind)
    extract(s, i, i + 1, ind)
  }
  console.log(ind)
  // dp[i] 前i个字符最少分隔成多少个回文子串
  let dp = Array(n + 1).fill(Infinity)
  // 前0个字符，也就是空字符，被分割的字串数目当然是0了
  dp[0] = 0
  for (let i = 1; i <= n; i++) {
    // 遍历前i个字符中，可以和结尾形成回文串的所有位置
    for (let j of ind[i]) {
      // j+1到i是一个回文串,所以可以进行状态转移
      dp[i] = Math.min(dp[i], dp[j] + 1)
    }
  }
  // 分割次数 = 分隔的字串数 - 1
  return dp[n] - 1
}
```
