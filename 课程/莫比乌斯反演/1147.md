1147. 段式回文

你会得到一个字符串 text 。你应该把它分成 k 个子字符串 (subtext1, subtext2，…， subtextk) ，要求满足:

subtexti 是非空字符串
所有子字符串的连接等于 text ( 即 subtext1 + subtext2 + ... + subtextk == text )
subtexti == subtextk - i + 1 表示所有 i 的有效值( 即 1 <= i <= k )
返回 k 可能最大值。

示例 1：

输入：text = "ghiabcdefhelloadamhelloabcdefghi"
输出：7
解释：我们可以把字符串拆分成 "(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)"。

```js
/**
 * @param {string} text
 * @return {number}
 */
var longestDecomposition = function (text) {
  const get = (text, l, r) => {
    let n = r - l + 1
    if (n <= 1) return n
    for (let i = 1; (i <= n / 2) | 0; i++) {
      let ok = true
      for (
        let j = l, k = r - i + 1;
        k <= r;
        j++, k++
      ) {
        if (text[j] != text[k]) {
          ok = false
          break
        }
      }
      if (ok) return get(text, l + i, r - i) + 2
    }
    return 1
  }
  return get(text, 0, text.length - 1)
}
```
