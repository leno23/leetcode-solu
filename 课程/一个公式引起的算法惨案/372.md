372. 超级次方

你的任务是计算 ab 对 1337 取模，a 是一个正整数，b 是一个非常大的正整数且会以数组形式给出。

示例 1：

输入：a = 2, b = [3]
输出：8

```js
/**
 * @param {number} a
 * @param {number[]} b
 * @return {number}
 */
var superPow = function (a, b) {
  // a = 2147483647, b = [2,1,2] 表示 2147483647^212  = 2147483647^(2 * 100) * 2147483647^(1 * 10) * 2147483647^(2 * 1)
  let M = 1337
  // 快速幂 计算a^b 计算过程
  // 思想：降幂的过程中，偶数次方可以通过[底数] 的 平方减少[幂次]，奇数次方可以分离出多余的数，
  // 等到幂次减少到0时，原数就等于所有分离出来的数字的乘积了

  // 例如计算 2^200 迭代法需要计算200次，而快速幂法只需要计算10次
  // 2^200 = (2^2)^100                                  计算1次
  //       = (2^4)^50                                   计算2次
  //       = (2^8)^25 = (2^8)^(2*12 + 1)                计算4次
  //       = (2^16)^12 * 2^8                            计算5次
  //       = (2^32)^6 * 2^8                             计算6次
  //       = (2^64)^3 * 2^8 = (2^64)^(2*1+1)            计算8次
  //       = (2^128)^1 * 2^8 * 2^64                     计算9次
  //       = (2^128)^0 * 2^8 * 2^64 * 2^128             计算10次
  // 最终得到答案
  // ans =  2^8 * 2^64 * 2^128
  const power = (a, b) => {
    // 由于(1337*x)^b % 1337 = x^b，也就是一个数x的1337倍 的b次方 对 1337取余，结果应该和x的b次方相等
    //  所以先对底数取余
    let base = a % M,
      ans = 1
    while (b) {
      // 遇到计数的幂需要分离出底数，成为最终的答案
      if (b & 1) ans = (ans * base) % M
      // 底数平方
      base = (base * base) % M
      // 幂次降低次方
      b >>= 1
    }
    return ans
  }
  let base = a,
    ans = 1
  // 从低位到高位求a的次方
  // 对于a=21,b=[2,1,2]来说，下面是计算过程
  // b        2        1            2
  // base     a       a^10        a^10^10
  // 21^212 = 21^2 * (21^10)^1 * (21^10^10)^2
  for (let i = b.length - 1; i >= 0; i--) {
    ans = (ans * power(base, b[i])) % M
    base = power(base, 10)
  }
  return ans
}
```
