60. 排列序列

给出集合 [1,2,3,...,n]，其所有元素共有 n! 种排列。

按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：

"123"
"132"
"213"
"231"
"312"
"321"
给定 n 和 k，返回第 k 个排列。

示例 1：

输入：n = 3, k = 3
输出："213"

```js
/**
 * @param {number} n
 * @param {number} k
 * @return {string}
 */
var getPermutation = function (n, k) {
  // 康托展开
  // 对于一组数字序列的全排列N，每个排列在N中的排名组成的序列(或者排名与当前排列的双向对应关系)，就是康托展开
  // 例如 1 2 3的全排列是  123 132 213 231 312 321 对应的康拓展开就是 0 1 2 3 4 5
  // 给定某个排列 abc 求这个排列的排名的运算是康托展开
  // 求排名是指定数字的 排列 指的是逆康托展开
  // 有了这些知识之后，就可以开始求解这道题目

  // 首先，定义参与排列的数字
  let chs = [
    '1',
    '2',
    '3',
    '4',
    '5',
    '6',
    '7',
    '8',
    '9'
  ]
  // 定义一个求a!的函数
  let fac = (a) => {
    let res = 1
    for (let i = 1; i <= a; i++) res *= i
    return res
  }
  let str = ''
  // 第k个排列前面有k-1个排列
  k--

  // 我们尝试将1 2 3 的全排列过程展开,如下图

  //  排列中第
  //  几位数字                    开始
  //                  /            |            \
  //  1              1             2              3
  //                / \           /  \            / \
  //  2            2   3          1   3          1  2
  //               |   |          |   |          |   |
  //  3            3   2          3   1          2   1
  //            123   132        213  231      312  321
  //康拓展开      0    1           2    3         4   5

  //  那么如何求第k个排列，也就是 第k-1位的排列呢？
  // 乍一看，不好求，但是我们可以首先确定第一位数字是多少。
  // 全排列过程是一个二叉树，容易发现一级子树的叶子节点个数是2！，那么第k-1位的排列前面有多少个以及子树呢？
  // 使用k-1/2! 就得到了，这样就得到了所求的排列的第一位的数字；第二位数字同样的求法，只不过需要注意的是，在生成全排列
  // 过程中，如果上次使用了一个数字之后，后面就不能用了，所以确定了第一位数字之后，需要将该数字从数字序列中删除。
  // 这时，假设 知道了第一位数字是1，那么在1这个子树中，想要确定第二个数字选择了谁？又需要知道上次k-1中剩余的数字 中有多少个二级子树。
  // 也就是 (k-1)%2! /1!,这样就得到了第二个数字，同理向后递归运算，最终可以得到整个排列。
  for (let i = n - 1; i >= 0; i--) {
    // 前面有多少个数字小于当前数字
    let ind = (k / fac(i)) | 0
    // 获取到排名是ind的数字
    str += chs[ind]
    chs.splice(ind, 1)
    k %= fac(i)
  }
  return str
}
```
