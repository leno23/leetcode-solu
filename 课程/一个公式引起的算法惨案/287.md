287. 寻找重复数

给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。

假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。

你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。

示例 1：

输入：nums = [1,3,4,2,2]
输出：2

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var findDuplicate = function (nums) {
    // 首先，n+1个数字如果没有重复，将他们依次放到按他们顺序排列的位置上的话，每个数字都有自己的一个位置，
    // 下标也就是数字本身。

    // n+1个数中只有两个数重复，如果依次将每个数组放到他们顺序排列的位置上，在放置过程中
    // 如果原来位置上已经有数字，则这个数字就是重复数
    // 又因为原题不能修改原数组，而且只能使用O(1)的空间复杂度

    // 那么，我们可以把每个数字增加一个下一步操作的指向位置，值就是数字本身
    // 例如：
    // 顺序排列的位置  0 1 2 3 4
    // 原数字数组      1 3 4 2 2     
    // 将1放到他的位置1上去，那么，1位置对应的数字3需要移动，那么将3放到他对应的位置上之后，发现3对应的数字2需要移动，
    // 那么将2放到他对应的位置2上去，然后4需要移动，那么将4放到它对应的位置4上面去，需要移动2，那么将2放到他对应的位置上的时候
    // 发现，位置上面已经有数字2了，所以2就为重复数字。
    // 这个过程可以抽象成链表的操作，next指针，对应每个数字在顺序排列时的位置，也就是数字本身
    // 原题也就转化成了求 链表是否存在环的问题了？ 故采用快慢指针方法
    // 1 -> 3 -> 2 -> 4 -> 2
    let slow = fast = 0
    do {
        fast = nums[nums[fast]]
        slow = nums[slow]
    } while (fast != slow)
    fast = 0
    while (nums[slow] != nums[fast]) {
        fast = nums[fast]
        slow = nums[slow]
    }
    return nums[slow]
};
```
