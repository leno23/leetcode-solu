//  计数排序
// 适用于固定值域的单值排序

/*
  例如，有以下序列  每个数字在1-4之间
  下标 0 1 2 3 4 5 6 7 
  数字 1 4 3 2 2 1 4 1

  使用计数排序，计数即统计个数。首先，由于数字的值域固定为1,2,3,4，
  首先按顺序统计各个数字出现的次数
  次数  3 2 1 2
  数字  1 2 3 4

  然后，可以确定最终排序结束时的序列是这样的 1 1 1 2 2 3 4 4，
  可以发现原序列分为了四个区，但是相同元素的顺序还不确定。
  为了保证数据的稳定性，即相同数字的前后顺序在排序后保持不变，
  可以统计每个分区的末尾坐标，然后倒叙遍历原数组；或统计起始坐标，正序遍历数组
  数字          1  2  3  4
  次数          3  2  1  2
  分区末尾坐标   2  4  5  7    取次数序列的前缀和 然后-1
  分区起始坐标   0  3  5  6 
  若采用 倒叙遍历方式，过程如下
                                                           
                                        数字    1 2 3 4    原序列                
结果数组ret  0  1  2  3  4  5  6  7     末尾坐标         1 4 3 2 2 1 4 1      当前遍历项 
                   1                           2 4 5 7                ^       1(所在分区末尾坐标为2)
                   1             4             1 4 5 7              ^         4(所在分区末尾坐标为7)
                1  1             4             1 4 5 6            ^           1(所在分区末尾坐标为1)
                1  1    2        4             0 4 5 6          ^             2(所在分区末尾坐标为4)
                1  1 2  2        4             0 3 5 6        ^               2(所在分区末尾坐标为3)
                1  1 2  2  3     4             0 2 5 6      ^                 3(所在分区末尾坐标为5)
                1  1 2  2  3  4  4             0 2 4 6    ^                   4(所在分区末尾坐标为6)
             1  1  1 2  2  3  4  4             0 2 4 5  ^                     1(所在分区末尾坐标为0)
  最终完成排序，而且相同的数据排序之后的顺序和在源数据中保持一致，即保证了数据的稳定性

# 基数排序[时间复杂度O(n)]
基数排序的过程可以看做是对数字的低位和高位依次进行了一次计数排序，由于计数排序的稳定性，在两次排序之后，
数据呈现有序。基数排序同样只适用于固定值域的数字进行排序
例如  31 23 21 13 12 33 12 32
对个位计数排序之后，变成 31 21 12 12 32 23 33
对十位排序之后，变成     12 12 21 23 31 32 33 ，即排序完成
由于对十位进行排序过程，保持了数据的稳定性，相同十位的数字排序时，依然保持数据的个位的排序顺序，
最终完成排序
*/
// 对两位十进制的数字进行排序
function sort(nums) {
  let cnt = Array(10).fill(0)
  let ret = Array(nums.length) // 结果数组长度和原数组保持一致
  // 个位进行计数排序
  for (let x of nums) cnt[x % 10]++         // 为每一个数字进行计数
  for (let i = 1; i < 10; i++) cnt[i] += cnt[i - 1]   // 前缀和，即各个分区的末尾坐标
  for (let i = nums.length - 1; i >= 0; i--) ret[--cnt[nums[i] % 10]] = nums[i]   // 将数字倒叙插入到结果数组中
  cnt.fill(0)
  // 十位进行计数排序
  for (let x of ret) cnt[x / 10 | 0]++         // 为每一个数字进行计数
  for (let i = 1; i < 10; i++) cnt[i] += cnt[i - 1]   // 前缀和，即各个分区的末尾坐标
  for (let i = nums.length - 1; i >= 0; i--) nums[--cnt[ret[i] / 10 | 0]] = ret[i]   // 将数字倒叙插入到结果数组中
}
let arr = Array(10).fill().map(() => Math.random() * 100 | 0)
console.log('排序前：', arr)
sort(arr)
console.log('排序后：', arr)

/*

# 扩展 排列任意32位非负整数
当需要排序的数字为非负整数，数值范围在32位字符整数内时，都可以使用基数排序
例如
3534362 23123231  5733444  21211374  2457834324   ........
可以将数字分为两部分   [高十六位][低十六位]
对低十六位和高十六位依次排序之后，就完成了整个序列的排序
还可以将数字看做一个65536进制的两位数字，#*
*/
function radix_sort(nums) {
  let cnt = Array(65536).fill(0)
  let ret = Array(nums.length)
  // 低十六位排序
  for (let i = 0; i < nums.length; i++) cnt[nums[i] % 65536]++
  for (let i = 1; i < 65536; i++) cnt[i] += cnt[i - 1]
  for (let i = nums.length - 1; i >= 0; --i) ret[--cnt[nums[i] % 65536]] = nums[i]
  cnt.fill(0)
  // 高十六位排序
  for (let x of ret) cnt[x / 65536 | 0]++
  for (let i = 1; i < 65536; i++) cnt[i] += cnt[i - 1]
  for (let i = nums.length - 1; i >= 0; --i) nums[--cnt[ret[i] / 65536 | 0]] = ret[i]
}

let random32 = () => 2 ** (Math.random() * 32 | 0)
let arr1 = Array(10).fill().map(() => Math.random() * random32() | 0)
console.log('排序前：', arr1)
radix_sort(arr1)
console.log('排序后：', arr1)