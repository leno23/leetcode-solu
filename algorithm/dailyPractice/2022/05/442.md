442. 数组中重复的数据

给你一个长度为 n 的整数数组 nums ，其中 nums 的所有整数都在范围 [1, n] 内，且每个整数出现 一次 或 两次 。请你找出所有出现 两次 的整数，并以数组形式返回。

你必须设计并实现一个时间复杂度为 O(n) 且仅使用常量额外空间的算法解决此问题。

示例 1：

输入：nums = [4,3,2,7,8,2,3,1]
输出：[2,3]

```js
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var findDuplicates = function (nums) {
    // 常规做法，使用哈希表记录每个数字出现的个数，将出现次数为2的数字输出
    // 但不符合空间复杂度要求
    // let m = {}, ret = []
    // for (let x of nums) {
    //     m[x] = (m[x] || 0) + 1
    //     if (m[x] == 2) ret.push(x)
    // }
    // return ret

    // 第二种，技巧性比较强
    // 由于 1<=num[i]<=n，所以如果数组中没有重复的数字，那么1-n这n个数字各出现了一次
    // 假设现在有n个空位，序号标记为0-n-1,我们把每个数字n丢到它对应的，也就是序号是nums[i]-1
    // 的空位上时，在丢之前空位都是空的。
    // 如果将它丢到对应的空位中时，发现空位已经有数字的话，这个数字就出现了两次

    // 现在可以把输入的数组nums当做这个空位，使用下标作为序号，即0~n-1来标记。
    // 我们从头到尾遍历每个数字，然后将他们丢到对应的空位中。
    // 由于原本的数字nums[i]都是正数，如果当前数字对应的空位中的数字是正数的话，
    // 证明这个数还没有被遍历到(或者说出现过)，此时，我们在空位中放入-nums[i]，
    // 负值标记他已经出现过，不使用-1而使用-nums[i]是让相同数字对应的空位序号不变，便于查重。
    // 那么在后面遍历时，如果遍历到的当前数字对应
    // 的空位(也就是下标abs(nums[i])-1对应的空位)是负数的话，就说明这个数字之前出现过了。
    // 至此，完成整个的思路分析了
    let res = [];
    for (let x of nums) {
        let index = Math.abs(x) - 1;
        // 这里使用-nums[i]原因是后面遇到相同的数字时可以通过abs(nums[i])找到正确对应的数字
        if (nums[index] > 0) nums[index] *= -1;
        else res.push(index + 1);
    }
    return res;
};
```
