'''
题目描述 
给定一个N行M列的二维矩阵，矩阵中每个位置的数字取值为0或1。矩阵示例如： 1100 0001 0011 1111 
现需要将矩阵中所有的1进行反转为0，规则如下： 1） 当点击一个1时，该1便被反转为0，同时相邻的上、下、左、右，以及左上、左下、右上、右下8 个方向的1（如果存在1）均会自动反转为0； 2）进一步地，一个位置上的1被反转为0时，与其相邻的8个方向的1（如果存在1）均会自动反转为0； 
按照上述规则示例中的矩阵只最少需要点击2次后，所有值均为0。请问，给定一个矩阵，最少需要点击几次后，所有数字均为0？ 
输入描述 
第一行输入两个整数，分别表示矩阵的行数N和列数M，取值范围均为[1,100]接下来N行表示矩阵的初始值，每行均为M个数，取值范围[0,1]。 
输出描述 
输出—个整数，表示最少需要点击的次数示例一。 
示例 1 
输入： 
3 3
1 0 1 
0 1 0 
1 0 1 
输出： 1 
 
 说明 上述样例中，四个角上的1均在中间的1的相邻8个方向上，因此只需要点击一次即可。 
 
输入：
4 4
1 1 0 0
0 0 0 1
0 0 1 1
1 1 1 1
输出： 2 
'''

'''
点击每个为1的点时，会向四周蔓延形成一个值都为0集合，点击集合中的任意一个值为1的点，都可以使得整个集合为0
所以，从第一个点开始点击，如果当前点已经访问过，则跳过；否则，将蔓延的点标记为已访问过，这样点击完所有点后，点击的次数机试
'''
n,m=[int(x) for x in input().split()]
g=[[0]*m for i in range(n)]
for i in range(m):
    r=[int(x) for x in input().split()]
    for j in range(m):
        g[i][j]=r[j]

dirs=[[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,-1],[1,-1],[-1,1]]
# 将i,j周围的1点变成0，并标记以访问
def dfs(i,j):
    mp[(i,j)]=1
    for dx,dy in dirs:
        x,y=dx+i,dy+j
        if (x,y) in mp or x<0 or x>=n or y<0 or y>=n or g[x][y]==0: continue
        dfs(x,y)
res=0
mp={}
for i in range(n):
    for j in range(n):
        # 当前点所在的集合已经处理了
        if (i,j) in mp or g[i][j]==0: continue
        # 点击当前的点
        dfs(i,j)
        res+=1
print(res)