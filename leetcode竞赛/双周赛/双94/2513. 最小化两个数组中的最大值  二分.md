2513. 最小化两个数组中的最大值

给你两个数组 arr1 和 arr2 ，它们一开始都是空的。你需要往它们中添加正整数，使它们满足以下条件：

arr1 包含 uniqueCnt1 个 互不相同 的正整数，每个整数都 不能 被 divisor1 整除 。
arr2 包含 uniqueCnt2 个 互不相同 的正整数，每个整数都 不能 被 divisor2 整除 。
arr1 和 arr2 中的元素 互不相同 。
给你 divisor1 ，divisor2 ，uniqueCnt1 和 uniqueCnt2 ，请你返回两个数组中 最大元素 的 最小值 。

 

示例 1：

输入：divisor1 = 2, divisor2 = 7, uniqueCnt1 = 1, uniqueCnt2 = 3
输出：4
解释：
我们可以把前 4 个自然数划分到 arr1 和 arr2 中。
arr1 = [1] 和 arr2 = [2,3,4] 。
可以看出两个数组都满足条件。
最大值是 4 ，所以返回 4 。


```py
class Solution:
    def minimizeSet(self, d1: int, d2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:
        '''
        由于不确定添加到几，所以假设添加到了x

        然后，可以将添加的数字分为三类
        1.只能添加到arr1中 2.只能添加到arr2中  3.可以添加到arr1或arr2中

        第一类数字 由于不能添加到arr2中，那么他们需要能被d2整除，同时又不能被d1整除
        第二类数字 由于不能添加到arr1中，那么他们需要能被d1整除，同时又不能被d2整除
        第三类数字 需要同时满足arr1和arr2的特性，也就是即不能被d1整除，也不能被d2整除

        然后，可以尝试计算这三类数字各自的数量
        第一类 need1 = x/d2-x/lcm(d1,d2),也就是在能被d2整除的数字中去掉同时能被d1整除的数字，剩下的就是能被d2整除不能被d1整除的数字
        同理，第二类的数量为 need2 = x/d1-x/lcm(d1,d2)
        第三类的数量为 common=  数字个数-能被d1或d2整除的个数 = x-(x/d1+x/d2-x/lcm(d1,d2))
        
        对于arr1，我们可以对比u1，也就是arr1中需要添加的数字个数，和当前数字范围中只能添加到arr1的数字个数 need1，可以知道arr1添加了这些数字之后，个数是否够了，也就是 max(0,u1-need1) 这个结果告诉我们arr1还需要添加的数字个数

        同理，max(0,u2-need2)就是arr2还需要添加的数字个数

        那么，就得到了添加到x时，arr1和arr2还需要添加的数字个数max(0,u1-need1)+max(0,u2-need2)
        然后，通过判断 common >= max(0,u1-need1)+max(0,u2-need2)我们就知道了添加到了x时，数字是否有剩余。
        如果有剩余，那么就可以再尝试添加更小的目标数字；否则，添加更大的目标数字

        这里拿具体示例1，举例说明
        假设现在从1开始向两个数组添加数字，添加到了11

        将其中 arr1  arr2 可能的序列打印出来
        arr1  1   3   5   7   9    11 
        arr2  1 2 3 4 5 6   8 9 10 11
        因为arr1中的数字不能被2整除，arr2中的数字不能被7整除。
        又因为arr1和arr2中数字各不相同，而arr2中的数字都不能被7整除，如果arr1中有和arr2相同的数字，那么这些数字一定是不能被7整除同时又不能被2整除的，例如1 3 5 9 11，也就是在添加数字过程中，这些数字可以添加到arr1也可以添加到arr2中。他们的数量是11 - (11/2+11/7-11/lcm(2,7))=11-(5+1-0)=5

        那么，有哪些数字是只能放到arr1的呢？换句话说，有哪些数字不能放到arr2里，只能放到arr1中？
        不能放到arr2中的数字能被7整除，可以放到arr1中的数字不能被2整除，所以满足这两个添加的数字，也就是不能被2整除又能被7整除的数字只能放到arr1中。这些数字有多少个呢？ 应该是11/7 - 11/lcm(2,7)=1，也就是从能被7整除的数字中去掉同时能被2整除的数
        又因为arr1包含u1=1个数，现在还剩下1-1=0个数需要填充

        同理，可以计算出只能放到arr2中还剩下 3-(11/2-11/lcm(2,7))=-2 也就是说添加到11时，填满arr2之后还多出来了两个数字

        所以，也就是说 添加到11时  arr1和arr2还需要填充的数字个数是0，  剩余可以添加的数字个数是5个，明显多出来了，也就是需要重新寻找一个 <11的数字，尽量让多出来的数字最少，这样添加的数字也更少，才会更接近最终的答案

        最终尝试过不同的数字x，也就是尝试添加到不同目标数字时，他们的数字盈余情况如下，1剩余0不剩余
        1   2   3   4   5   6   7   8   9   10   11
        0   0   0   1   1   1   1   1   1    1   1

        相当于在0 0 0 1 1 1中找第一个1，二分查找
        '''
        lcm = math.lcm(d1, d2)
        # 添加到数字x是否可以填满arr1 arr2
        def check(x: int) -> bool:
            # 还需要向arr1中添加多少个数字
            left1 = max(uniqueCnt1 - x // d2 + x // lcm, 0)
            left2 = max(uniqueCnt2 - x // d1 + x // lcm, 0)
            # 可以添加到arr1 或arr2中的数字个数
            common = x - (x // d1 + x // d2 - x // lcm)
            # 是否可以填满arr1 arr2
            return common >= left1 + left2
        l,r=1,10**15
        while l<r:
            mid = l+r>>1
            # 二分找到第一个check()==True的x
            # 相当于 0 0 0 1 1 1中二分找第一个1
            # check()=False  需要从从右半部分找更大的x
            if not check(mid):
                l=mid+1
            else:
                r=mid
        return l
```