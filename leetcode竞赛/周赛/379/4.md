100154. 执行操作后的最大分割数量 
给你一个下标从 0 开始的字符串 s 和一个整数 k。

你需要执行以下分割操作，直到字符串 s 变为 空：

选择 s 的最长前缀，该前缀最多包含 k 个 不同 字符。
删除 这个前缀，并将分割数量加一。如果有剩余字符，它们在 s 中保持原来的顺序。
执行操作之 前 ，你可以将 s 中 至多一处 下标的对应字符更改为另一个小写英文字母。

在最优选择情形下改变至多一处下标对应字符后，用整数表示并返回操作结束时得到的最大分割数量。

 

示例 1：

输入：s = "accca", k = 2
输出：3
解释：在此示例中，为了最大化得到的分割数量，可以将 s[2] 改为 'b'。
s 变为 "acbca"。
按照以下方式执行操作，直到 s 变为空：
- 选择最长且至多包含 2 个不同字符的前缀，"acbca"。
- 删除该前缀，s 变为 "bca"。现在分割数量为 1。
- 选择最长且至多包含 2 个不同字符的前缀，"bca"。
- 删除该前缀，s 变为 "a"。现在分割数量为 2。
- 选择最长且至多包含 2 个不同字符的前缀，"a"。
- 删除该前缀，s 变为空。现在分割数量为 3。
因此，答案是 3。
可以证明，分割数量不可能超过 3。

```py
class Solution:
    def maxPartitionsAfterOperations(self, s: str, k: int) -> int:
        if k==26: return 1
        a=[ord(x)-97 for x in s]
        n=len(a)
        @cache
        def dp(i,s,t,cur):
            if i==n: return cur
            s2=s | (1 << a[i])
            res=0
            if s2.bit_count() > k:
                res = max(res,dp(i+1,1<<a[i],t,cur+1))
            else:
                res = max(res,dp(i+1,s2,t,cur))
            if t<=0: return res
            for j in range(26):
                s2 = s | (1<<j)
                if s2.bit_count() > k:
                    res = max(res,dp(i+1,1<<j,t-1,cur+1))
                else:
                    res=max(res,dp(i+1,s2,t-1,cur))
            return res
        return dp(0,0,1,1)
```