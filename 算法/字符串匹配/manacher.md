```js
var countSubstrings = function (s) {
    let t = '@#'
    for (let x of s) t += x + '#'
    let n = t.length
    t += '!'
    let m = 0, r = 0, f = Array(n).fill(0), res = 0

    for (let i = 1; i < n; i++) {
        f[i] = i <= r ? Math.min(f[2 * m - i], r - i + 1) : 1
        while (t[i + f[i]] == t[i - f[i]]) f[i]++

        if (i + f[i] - 1 > r) {
            m = i
            r = i + f[i] - 1
        }
        res += f[i] / 2 | 0
    }
    return res
};
```




我的一点思考，希望能帮到别的童鞋~。

解释第1个为什么：

假设原字符串中，第i个字符最大回文串长度为L，经过马拉车算法处理后的回文字符串长度增加了L+1，总长度为2L+1.已知在处理后的字符串中，第i个字符的最大回文半径为f(i), 则其回文字符串长度为2*f(i)-1 = 2L+1, 由此可知 L = f(i)-1。

解释第2个为什么：

---X----j---------Im---------i------Rm---

上图中，以im为中心的最长回文字符串的右端端点为Rm, 如果i<=Rm，说明 i 被包含在im为中心的最长回文字符串中，假设j是最长回文字符串中i在左侧的对称位置，再假设X是最长回文串Rm对应的最左端断点，其中X<=j，已知以j为中心的回文字符串长度为f(j), f(i)的初始化分下列两种情况：

case 1： 如下图所示， 如果j的最长回文串的最左侧端点y不在X的左侧(在右侧或者与X重合)，说明y也包含在i的最长回文字符串中，根据i和j的对应关系可知f(i) >= f(j)，并且f(j) <= Rm -i+1, 因此把f(i)初始化为f(j)。

---X--y--j--y------Im-------y--i--y----Rm---

case 2： 如下图所示，如果j为中心的最长回文串的最左侧端点在X左侧，说明y不在i的最长回文字符串中，此时Rm-i+1 < f(j), 根据i和j的对应关系，我们最多可知f(i) 的长度至少为 Rm -i +1,因此把f(i)初始化为Rm-i+1。

-y--X------j--------Im---------i------Rm---

综合case1 和case2， f(i)的长度最大不应该超过Rm-i+1, 因此f(i) = min(f(j), Rm -i +1);