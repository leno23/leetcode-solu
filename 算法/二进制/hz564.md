## 564. 起床困难综合症

题目描述

​ 21 世纪，许多人得了一种奇怪的病：起床困难综合症。其临床表现为：起床困难，起床后精神不佳。作为一名青春阳关好少年，路飞一直坚持与该症作斗争。通过研究发现，他得到了该病的发病原因：在深邃的太平洋海底中，出现了一条名为drd 的巨龙，它掌握着睡眠之精髓，能随意延长大家的睡眠时间。正是由于drd 的活动，起床困难综合症愈演愈烈，以惊人的速度在世界上传播。为了彻底消灭这种病，路飞决定前往海底，消灭这条恶龙。

​ drd 有着十分特殊的技能，它的防御战线能够使用一定的运算来改变它受到的伤害。具体来说，drd 的防御战线由 n 扇门组成。每扇门包括一个运算 op 和一个参数 t ，其中运算一定是 OR 、XOR 、AND 中的一种，参数一定是非负整数。如果还未通过防御门时攻击力为 x ，则其通过这扇防御门后攻击力将变为 x op t 。最终 drd 所受到的伤害为对方初始攻击力 x 依次经过所有 n 扇门后转换得到的攻击力。

​ 路飞的初始攻击力只能为 0 ~ m 之间的一个整数(即他的初始攻击力只能在 0 ~ m 中任选，但通过防御门后的攻击力不受 m 的限制)。为了节省体力，路飞希望通过选择合适的初始攻击力使得他的攻击能让 drd 受到最大的伤害，请帮他计算一下，他的一次攻击最多能使 drd 受到多少伤害。

输入

​ 第 1 行包含 2 个整数，依次为 n 和 m ，表示 drd 有 n 扇防御门，路飞的初始攻击力为 0 ~ m 之间的整数。

​ 接下来的 n 行，依次表示每一扇门，每行包括一个字符串 op 和一个非负整数 t ，两者由一个空格隔开。

输出

​ 共一行一个整数，表示路飞的一次攻击最多使 drd 受到多少伤害。

样例输入

3 10

AND 5

OR 6

XOR 7

样例输出


1

数据规模与约定

​ 时间限制：1 s

​ 内存限制：256 M

​ 100% 的数据保证 0≤m,t≤109，2≤n≤105
```c
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

using namespace std;

int n, m,t[100010],a[100010],ans;

// 攻击力x通过n扇防御门之后的攻击力,也就是对巨龙产生的伤害
int sum(int x){
    for (int i = 1; i <= n; i++){
        if (a[i] == 1)   x &= t[i];
        if (a[i] == 2)   x |= t[i];
        if (a[i] == 3)   x ^= t[i];
    }
    return x;
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++){
        char op[10];
        scanf("%s%d", op, &t[i]);
        if (op[0] == 'A')  a[i] = 1;
        else if (op[0] == 'O') a[i] = 2;
        else a[i] = 3;
    }
	// 由于需要求最大值，从二进制高位到低位进行遍历
	// 对结果数字 二进制 逐位进行判断
    for (int i = 30; i >= 0; i--){
		// 超过限制跳过
		if (ans + (1 << i) > m) continue;
		int x = sum(ans), y = sum(ans + (1 << i));
		// 当前位变为1后，如果攻击力变为一个更大数，也就是造成更多伤害，则将当前位置为1
		if (x < y)  ans += (1 << i);
    }
    printf("%d", sum(ans));

    return 0;
}
