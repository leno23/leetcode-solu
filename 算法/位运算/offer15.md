```js
/**
 * @param {number} n - a positive integer
 * @return {number}
 */
var hammingWeight = function (n) {
    // 32位无符号整数占4个字节 一个字节8个二进制位,最大数为0xffffffff 一个f代表一段4个为1的二进制位
    // 0x55555555  =  01010101 01010101 01010101 01010101
    // 0x33333333  =  00110011 00110011 00110011 00110011
    // 0x0f0f0f0f  =  00001111 00001111 00001111 00001111  

    // 1.遍历每两个二进制位，把高位和低位的值放到两个二进制位中的低位上，然后相加，就会得到这两个二进制位中1的实际数量
    /* 例如  
     0111  -->  0101(低位) + 0001(高位) = 0110
    01=1  代表01 这两个二进制位中1的个数
    10=2  代表11 这两个二进制位中1的个数
    */
    // n = (n & 0x55555555) + ((n >> 1) & 0x55555555);  // 分为2个一组
    // 简写如下
    n = n - ((n >>> 1) & 0x55555555)

    /* 2.遍历每四个二进制位，将高的两位中1的个数 和 低的二位中1的个数相加，放到这四个二进制位上，表示这四个二进制位实际1的个数
     而第一步已经算出每两个二进制位中1的个数，所以这里只需要将前后两个二进制位中1的个数相加即可
    */
    n = (n & 0x33333333) + ((n >>> 2) & 0x33333333);  // 分为4个一组


    /*3.和前两步相同，遍历每八个二进制位，将高四位中1的个数 和 低四位中1的个数相加，因为四个二进制位最大数是1111=15 可表示8个二进制位中1的个数，所以可以直接相加，少了一次&运算，提升效率
     */
    // n = (n & 0x0f0f0f0f) + ((n >> 4) & 0x0f0f0f0f);   // 分为8个一组
    // 4个二进制位最大数字为1111=15  可以表示 8个位中1的个数，所以直接相加后，取每8位中的后四位即可
    n = (n + (n >>> 4)) & 0x0f0f0f0f

    /* 4.每次遍历16个二进制位，做法和上面相同，不需要& 0x0000ffff,现在高16位和低16位中的1的个数都存放到了
    其中的后8位中
     */
    // n = (n & 0x00ff00ff) + ((n >> 8) & 0x00ff00ff);   // 分为16个一组 
    n = n + (n >>> 8)

    /* 5.将高16位和低16位中各自的数字直接相加得到 32位二进制中1的个数 */ 
    // n = (n & 0x0000ffff) + ((n >> 16) & 0x0000ffff);
    n = n + (n >>> 16)
    console.log(n.toString(2))
    // 因为 1的个数最多32个,对应到二进制位上，不会超过6位,所以最终的答案只需要取后6位即可  111111=63 > 32
    return n & 0b111111;
};