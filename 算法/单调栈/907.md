907. 子数组的最小值之和

给定一个整数数组 arr，找到 min(b) 的总和，其中 b 的范围为 arr 的每个（连续）子数组。

由于答案可能很大，因此 返回答案模 10^9 + 7 。

 

示例 1：

输入：arr = [3,1,2,4]
输出：17
解释：
子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。 
最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。
```js
/**
 * @param {number[]} arr
 * @return {number}
 */
/* 如果根据题意进行模拟，则遍历所有子数组需要O(n2)的复杂度，再加上求每个子数组的最小值，
    总体会有O(n^3)的复杂度，会超时

    可以尝试找到以某个数字arr[i]为最小值的子数组的个数n，那么 当前的数字对答案的贡献就是arr[i]*n
    将每个数字对答案的贡献求和，即可得出答案。

    如何求以为arr[i]最小值的子数组的个数？因为子数组是连续的
    可以使用【单调栈】求x左边第一个小于它的数字的位置l[i]，和右边第一个小于它的数字的位置r，那么以l+1~i为开头，
    以i~r为结尾的子数组都会满足最小值 = x，因为区间[l+1,r-1]中的数字都是>= x的
    然后，根据乘法原理 子数组左侧有 i-[i]种，右侧有r[i]-i种，最终数字i对答案的贡献就是arr[i]*(i-l[i])*(r[i]-i)

    最后，将每个数对答案的贡献相加即可
*/ 
var sumSubarrayMins = function (arr) {
    arr.push(-Infinity);//为了确保全部计算，人为添加一个下界
    let n = arr.length
    let pre = Array(n).fill(0)//维护前一个更小元素的位置，在入栈时得出
    let st = [];//单调递减栈，保存下标
    let ans = 0, mod = 1e9 + 7;
    for (let i = 0; i < n; ++i) {
        //出栈并进行计算
        while (st.length && arr[st[st.length - 1]] >= arr[i]) {
            let now = st[st.length - 1];
            ans = (ans + (now - pre[now]) * (i - now) * arr[now]) % mod;
            st.pop();
        }
        pre[i] = st.length ? st[st.length - 1] : -1;//保存前一个更小元素的位置
        st.push(i);
    }
    return ans;

};