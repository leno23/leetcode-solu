1872. 石子游戏 VIII

提示

2440

45

[第 242 场周赛](https://leetcode.cn/contest/weekly-contest-242)[Q4](https://leetcode.cn/contest/weekly-contest-242/problems/stone-game-viii)

相关企业

Alice 和 Bob 玩一个游戏，两人轮流操作， **Alice 先手** 。

总共有 `n` 个石子排成一行。轮到某个玩家的回合时，如果石子的数目 **大于 1** ，他将执行以下操作：

1.  选择一个整数 `x > 1` ，并且 **移除** 最左边的 `x` 个石子。
1.  将 **移除** 的石子价值之 **和** 累加到该玩家的分数中。
1.  将一个 **新的石子** 放在最左边，且新石子的值为被移除石子值之和。

当只剩下 **一个** 石子时，游戏结束。

Alice 和 Bob 的 **分数之差** 为 `(Alice 的分数 - Bob 的分数)` 。 Alice 的目标是 **最大化** 分数差，Bob 的目标是 **最小化** 分数差。

给你一个长度为 `n` 的整数数组 `stones` ，其中 `stones[i]` 是 **从左边起** 第 `i` 个石子的价值。请你返回在双方都采用 **最优** 策略的情况下，Alice 和 Bob 的 **分数之差** 。

 

**示例 1：**

```
输入： stones = [-1,2,-3,4,-5]
输出： 5
解释：
- Alice 移除最左边的 4 个石子，得分增加 (-1) + 2 + (-3) + 4 = 2 ，并且将一个价值为 2 的石子放在最左边。stones = [2,-5] 。
- Bob 移除最左边的 2 个石子，得分增加 2 + (-5) = -3 ，并且将一个价值为 -3 的石子放在最左边。stones = [-3] 。
两者分数之差为 2 - (-3) = 5 。
```

```py
class Solution:
    def stoneGameVIII(self, A: List[int]) -> int:
        n=len(A)
        # 原数组从前往后拿数字，倒序后可以将问题变为从后往前拿数字，方便求解
        A.reverse()
        pre=[0]*(n+1)
        for i in range(n):
            pre[i+1]=pre[i]+A[i]
        '''
        首先需要知道的是，数组的长度变为i时，当前数组是确定的。

        因为每次从前面拿x个数后，会往数组放一个大小和x个数和相同的数
        那么，剩余的i个数的总和不会改变，而且i+1后面的数字都是不变的，所以所有长度为i的数组都是一样的

        然后，就可以把剩余的数字个数作为状态，进行递推
        f[i]表示剩余i个数字时，先手与后手的最大得分差

        __________|________|
               j j+1      i-1   
        假设当前剩余i个数，从后面拿了x个数之后，最后一个数下标为j，即j=i-1-x
        那么，Alice的得分为s[n]-s[j]，剩下的j+1个数，对于Bob来说是先手，所以他的得分为f(j+1)。
        所以，面对i个数字时，先手后手得分差为f[i]=∑max(s[n]-s[i-x]-f[i-x+1]) (i>x>1)。
        
        注意到，当前求解f[i]需要O(n)时间枚举2~i-1的所有值，从而最终求解f[n]的时间复杂度为O(n^2)，需要优化。

        将数组有i个数，取x个数后的得分记为 g(x)=s[n]-s[i-x]-f(i-x+1)
        那么有 
        f[2] = g(2)
        f[3] = max(g(2),g(3))
        f[4] = max(g(2),g(3),g(4))
        ...

        也就是说，f(x)是序列g(2) g(3) ... 的前缀最大值,为了快速求这个最大值，
        可以在从小到大求解f[i]时，维护前若干项g(x)的最大值，每次计算一个新的f[i]的值，只需要更新g(x)即可。
        这样就可以在O(n)时间中求出f[i]
        ''' 
        f=[0]*(n+1)
        gx=pre[n]-pre[0]+f[1]
        for i in range(2,n+1):
            f[i]=gx
            gx=max(gx,pre[n]-pre[i-1]-f[i])
        return f[n]