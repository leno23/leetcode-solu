10. 正则表达式匹配

给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。

 
示例 1：

输入：s = "aa", p = "a"
输出：false
解释："a" 无法匹配 "aa" 整个字符串。
```js
var isMatch = function (s, p) {
    // dp[i][j] s前i项和p前i项是否匹配
    let m = s.length, n = p.length
    let dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0))
    dp[0][0] = 1
    // a*、 a*.*  可以匹配任意字符
    for (let j = 2; j <= n; j += 2) {
        dp[0][j] = dp[0][j - 2] && p[j - 1] == '*'
    }
    // 递推过程看做从s p的第一个字符开始匹配，
    // 然后分别给sp追加一个字符之后，讨论匹配情况

    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (p[j - 1] == '*') {
                // xxxp[j-1]* 如果xxx可以和s匹配，那么只要p[i-1]出现0次即可匹配
                if (dp[i][j - 2]) dp[i][j] = 1
                // 例如 aa ab*.*
                // p最后一个字符为*，但是 ab*和aa并不匹配
                // 但是 s 0~i-1 即a可以和ab*.*匹配，而且p中星号前面字符为. ，
                // 由于 . 可以匹配a，而星号可以匹配多个a，这样 ab*.* 就既可以匹配a也可以匹配aa了
                else if (dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.')) dp[i][j] = 1
            } else {
                // 如果i-1与j-1不匹配，则sp后面增加一个字符之后也不匹配
                if (!dp[i - 1][j - 1]) continue
                // i-1与j-1匹配，最后一位相同或者 p[j-1]='.' 可以匹配
                if (s[i - 1] == p[j - 1] || p[j - 1] == '.') dp[i][j] = 1
            }
        }
    }

    return dp[m][n]
};