72. 编辑距离

给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。

你可以对一个单词进行如下三种操作：

插入一个字符
删除一个字符
替换一个字符
 

示例 1：

输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```js
/**
 * @param {string} word1
 * @param {string} word2
 * @return {number}
 */
var minDistance = function (word1, word2) {
    // 动态规划 将dp[i][j]看做 word1前i位可以通过dp[i][j]成功变为word2前j位
    let n = word1.length;
    let m = word2.length;

    // 有一个字符串为空串
    if (n * m == 0) {
        return n + m;
    }

    // DP 数组
    // dp[i][j]  word1前n位和word2前m位成功匹配的交换次数
    let dp = Array(n + 1).fill().map(() => Array(m + 1).fill(0));

    // 边界状态初始化
    // word2是空字符串的话，word1的前i位变为他的操作次数是word1的长度
    for (let i = 0; i < n + 1; i++) {
        dp[i][0] = i;
    }
    
    // word1是空字符串的话，word2的前i位变为他的操作次数是word2的长度
    for (let j = 0; j < m + 1; j++) {
        dp[0][j] = j;
    }

    // 计算所有 DP 值
    for (let i = 1; i < n + 1; i++) {
        for (let j = 1; j < m + 1; j++) {
            // word1[i-1]==word2[j-1]那么word1前i位变成word2前j位的次数等于 word1前i-1位变成word2前j-1位的次数
            if (word1[i - 1] == word2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1]
            } else {
                // 不同的话
                // 因为需要从word1变成word2
                // 可以尝试使用三种操作
                // 替换操作 因为知道i-1 j-1匹配成功次数为dp[i-1][j-1],
                    // 那么替换的次数为dp[i-1][j-1]+1
                // 删除操作 i-1 j匹配成功的最小次数为dpp[i-1][j],
                    // 这时可以删除word1[i]就可以匹配成功,替换次数为dp[i-1][j]+1
                // 插入字符操作 j j-1匹配成功的最小次数为dp[i][j-1]，
                    // 这时可以加上word2[j]字符就可以是的word1与word2匹配成功,次数dp[i][j-1] + 1
                // 最后取三者操作结果的最小值，作为0-i变成i-j的最小操作数
                dp[i][j] = 1 + Math.min(dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j])
            }
        }
    }
    return dp[n][m];
};