10. 正则表达式匹配

给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。

 
示例 1：

输入：s = "aa", p = "a"
输出：false
解释："a" 无法匹配 "aa" 整个字符串。
```js
var isMatch = function (s, p) {
    // dp[i][j] s前i项和p前j项是否匹配
    let m = s.length, n = p.length
    let dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0))
    dp[0][0] = 1
    // 初始化一些可以匹配空字符的状态
    for (let j = 2; j <= n; j += 2) {
        // p=xxxb*  如果xxx可以和""匹配，如果最后一个字符是*，整个p也可以和""匹配
        dp[0][j] = dp[0][j - 2] && p[j - 1] == '*'
    }
    // 递推过程看做从s p的第一个字符开始匹配，
    // 然后分别给sp追加一个字符之后，讨论匹配情况

    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (p[j - 1] == '*') {
                // xxxb* 如果xxx可以和s匹配，那么只要b出现0次即可匹配
                if (dp[i][j - 2]) dp[i][j] = 1
                /**
                p=xxxb* 如果p的前i-1位xxxb可以匹配s，那么有两种情况可以使得xxxb*也匹配s
                1.s最后一位和 p中*前字符一样，这样*可以充当出现一次，即s[i-1]==p[j-2]
                2.p*前面的字符是. 这样. 也可以代替s最后一位,和上面起到相同的作用
                */ 
                else if (dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.')) dp[i][j] = 1
            } else {
                // 如果p前j-1位可以匹配s的前i-1位
                if (dp[i - 1][j - 1]){
                    // 那么p的最后一位是 . 或者和s最后一位相同都可以匹配成功
                    if (s[i - 1] == p[j - 1] || p[j - 1] == '.') dp[i][j] = 1
                }
            }
        }
    }

    return dp[m][n]
};