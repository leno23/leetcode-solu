120. 三角形最小路径和

给定一个三角形 triangle ，找出自顶向下的最小路径和。

每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。

 

示例 1：

输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
输出：11
解释：如下面简图所示：
   2
  3 4
 6 5 7
4 1 8 3
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。
```py
class Solution:
    def minimumTotal(self, t: List[List[int]]) -> int:
        ''' 
        # 思路1：按照题意从上到下递推
        # i\j  0  1  2  3
        # 0    2
        # 1    3  4
        # 2    6  5  7
        # 3    4  1  8  3
        # 从上到下存在递推关系: 位于从0,0到i,j的最小路径 
        #     = min(到i-1,j的最小路径, 到i-1,j-1的最小路径(如果存在的话))
        # 初始化：dp[0][0]=t[0][0]即0,0到0,0点的最小路径为t[0][0]
        # 递推公式: dp[i][j] = min(dp[i-1][j], j>0 ? dp[i-1][j-1]: Infinity)
        # 优化：考虑到i层的状态只依赖于i-1层的状态，所以只需要两个数组就可以完成递推过程
        # i%2 得到当前层在两个数组中的位置，那么上个状态就是1-i%2
        n=len(t)
        dp = []
        for i in range(2): dp.append([inf for i in range(n)])
        dp[0][0]=t[0][0]
        for i in range(1,n):
            for j in range(i+1):
                cur = i % 2
                prev = 1-cur
                dp[cur][j]=dp[prev][j]+t[i][j]
                if j>0:
                    dp[cur][j] = min(dp[cur][j],dp[prev][j-1]+t[i][j])
        return min(dp[(n-1)%2])
        '''
        '''
        # 思路2：逆向思维 从下到上递推
        # 和思路1类似，只不过计算路径时，以最后一行上的数字作为起始数字，然后从倒数第二行开始向上递推
        # 具体的，最后一行的点到i,j位置的最小路径为min(最后一行到i+1,j的最小路径，最后一行到i+1,j+1的最小路径)，由于从下往上时，每个节点都有两个来源的点，相对比从上往下，少了一个判断
        # 递推公式：dp[i][j]=min(dp[i+1][j],dp[i+1][j+1])
        # 初始化：最后一行节点的最小路径即为节点值
        n=len(t)
        dp = t[n-1]
        for i in range(n-2,-1,-1):
            for j in range(i+1):
                dp[j]=min(dp[j+1],dp[j])+t[i][j]
        return dp[0]
        '''

        ''' 
        # 思路3：原地修改
        # 与思路2类似，可以直接将数组当做dp数组使用
        for i in range(len(t)-2,-1,-1):
            for j in range(i+1):
                t[i][j]+=min(t[i+1][j],t[i+1][j+1])
        return t[0][0]
        '''
```