## 574. 指数序列

题目描述

​ 伊凡在纸上写了一个由 n 个非负整数组成的序列 a1，a2，...，an。这个序列保证单调不降。

​ 接着，伊凡又在纸上写了另一个序列 2a1，2a2，...，2an。现在他想知道，最少要在这个序列中添加多少个形式为 2x 的数( x 为非负整数)，才能使这个序列所有整数的和为 2^v−1，其中 v 为某个非负整数。

输入

​ 第 1 行包括 1 个正整数 n (1≤n≤105)。

​ 第 2 行包括 n 个由空格隔开的整数 a1，a2，...，an。其中，0≤ai≤2×10^9，保证a1≤a2≤...≤an。

输出

​ 输出一行一个整数，表示最少在序列中添加数的数量。

样例输入

4

0 1 1 1

样例输出

0

数据规模与约定

​ 时间限制：1 s

​ 内存限制：256 M
```c
/* 4

    0 1 1 1
    0 1 2

    2^n 相当于在第n个二进制位上为1，最终结果为x^v-1  即需要0~v-1二进制位上均为1
    而两个相同位上为1，则会向高位进位，也就是 0 1 1 1相当于 0 1 2  -->转化为二进制为  111

    经过这样转化之后，如果是连续数字，则说明二进制位上是连续的1，否则，答案位数字之间的差值的和
    例如
    5
    0 1 3 3 5 7  -->  0 1 4 5 7  差的数字是2 3 6,所以最终答案为3

*/
#include <iostream>
#include <set>
using namespace std;

int n, ans;
set<int> se;

int main() {
   cin >> n;
// 防止只有一个数时，没有进行计算
	se.insert(-1);
	for (int i = 0; i < n; i++) {
		int t;
		cin >> t;
        // 如果有相同的数字，要一直进位，直到当前位没有发生进位，就插入到集合中
		while(se.find(x) != se.end()) se.erase(x++);
		se.insert(x);
		
	}
	set<int>::iterator it, it2;
	it = it2 = se.begin();
	it2++;
	while(it2 != se.end()){
		ans += (*it2 - *it - 1);
		it++,it2++;
	}
    cout << ans << endl;
    return 0;
}