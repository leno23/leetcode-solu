1696. 跳跃游戏 VI

1954

118

[第 220 场周赛](https://leetcode.cn/contest/weekly-contest-220)[Q3](https://leetcode.cn/contest/weekly-contest-220/problems/jump-game-vi)

相关企业

给你一个下标从 **0** 开始的整数数组 `nums` 和一个整数 `k` 。

一开始你在下标 `0` 处。每一步，你最多可以往前跳 `k` 步，但你不能跳出数组的边界。也就是说，你可以从下标 `i` 跳到 `[i + 1， min(n - 1, i + k)]` **包含** 两个端点的任意位置。

你的目标是到达数组最后一个位置（下标为 `n - 1` ），你的 **得分** 为经过的所有数字之和。

请你返回你能得到的 **最大得分** 。



**示例 1：**

```
输入： nums = [1,-1,-2,4,-7,3], k = 2
输出： 7
解释： 你可以选择子序列 [1,-1,4,3] （上面加粗的数字），和为 7 。
```

```py
class Solution:
    def maxResult(self, nums: List[int], k: int) -> int:
        n=len(nums)
        f=[0]*n
        f[0]=nums[0]
        '''
        f[i]代表跳到i位置时的最大得分
        跳到i位置的最大得分 = 跳到i-k到i-1位置的最大得分,他们分别尝试跳到i位置时,得分的最大值
        而 跳到i-k到i-1位置的最大得分 又可以根据这个递推关系继续向前推。
        直到跳到第一个位置i=0时,最大得分为nums[0]

        按照上述思路,从小到大计算f[i],代码如下
        for i in range(1,n):
            f[i]=-10**9
            for j in range(max(i-k,0),i):
                f[i]=max(f[i],f[j]+nums[i])
        不出意外,超时了,回头一看数据范围,才知道n k都是10**5量级。
        上面算法的时间复杂度为 O(nk),计算量会达到10**10,所以超时了

        再看上面的递推过程,由于需要递推出每个f[i],才能得到最终的答案,所以外层循环是必要的.

        那么问题就变成,有没有办法优化掉内层循环.
        也就是快速得到一个数字x 左侧k个数字中比它大的数字,这个就可以考虑使用单调队列。

        用它对f[i]序列进行处理,每次得到一个新的f[i]时,将它与队列尾部元素last比较.
        如果比last大,队列弹出尾部元素,直到队列为空或者 last>f[i].

        这样处理之后,保证队列中存放的都是当前元素nums[i]左侧大于他的数字,而且是单调递减的.
        队首元素start就是nums[i]左侧第一个大于nums[i]的元素.
        在状态转移时,我们每次从队首元素位置开始转移就是最优的。

        其次,在计算一个新的f[i]之后,还需要考察队首元素位置和nums[i]的距离.
        如果距离超过k,则需要弹出队首元素,因为已经不满足题目的范围条件了。

        优化之后,代码如下
        '''
        # print(f)
        q=deque([0])
        for i in range(1,n):
            # 最左侧数字位置和 i的距离超过k,不满足转移条件,从队首弹出
            if q and i-q[0]>k: q.popleft()
            # 此时,队首数字就是满足范围条件的, i位置左侧的大于nums[i]的数字
            f[i]=nums[i]+f[q[0]]
            # 进入元素后，对单调队列重新进行调整，使他满足单调特性
            while q and f[i]>=f[q[-1]]: q.pop()
            # 调整后f[i]对应的 i入队
            q.append(i)
        return f[-1]