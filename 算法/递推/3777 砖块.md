3777. 砖块

n� 个砖块排成一排，从左到右编号依次为 1∼n1∼�。

每个砖块要么是黑色的，要么是白色的。

现在你可以进行以下操作若干次（可以是 00 次）：

选择两个相邻的砖块，反转它们的颜色。（黑变白，白变黑）

你的目标是通过不超过 3n3� 次操作，将所有砖块的颜色变得一致。

#### 输入格式

第一行包含整数 T�，表示共有 T� 组测试数据。

每组数据第一行包含一个整数 n�。

第二行包含一个长度为 n� 的字符串 s�。其中的每个字符都是 `W` 或 `B`，如果第 i� 个字符是 `W`，则表示第 i� 号砖块是白色的，如果第 i� 个字符是 `B`，则表示第 i� 个砖块是黑色的。

#### 输出格式

每组数据，如果无解则输出一行 −1−1。

否则，首先输出一行 k�，表示需要的操作次数。

如果 k>0�>0，则还需再输出一行 k� 个整数，p1,p2,…,pk�1,�2,…,��。其中 pi�� 表示第 i� 次操作，选中的砖块为 pi�� 和 pi+1��+1 号砖块。

如果方案不唯一，则输出任意合理方案即可。

#### 数据范围

1≤T≤101≤�≤10，  
2≤n≤2002≤�≤200。

#### 输入样例：

```
4
8
BWWWWWWB
4
BWBB
5
WWWWW
3
BWB
```

#### 输出样例：

```
3
6 2 4
-1
0
2
2 1
```



```py
'''
由于砖块最终只能变成 WWWW...WWW 或者BBBB...BBB,分别尝试把砖块变成这两种看是否成功

例如：

 ^ ^ ^ ^ ^ ^ ^
B W W W W W W B    记n为砖块的个数
由于每次翻转相邻的两个颜色,而且相邻两块砖如果翻转两次的话，颜色不变。

翻转的砖块下标只能是 01 12 23 34 ....，也就是，最多会翻转 n-1次。

可以发现第一块转最多只能翻转一次，如果最终要变成WWWWWW，
那么，根据A[0]的颜色是W还是B可以确定第一次要不要翻转，确定第一次的操作之后，A[1]的颜色可以确定了，然后根据A[1]是不是W可以确定第二次
要不要翻转，这样有可以确定下来第三块转A[2]的颜色，这样根据A[2]的颜色是不是W可以确定第三次要不要翻转，... 这样最终可以确定n-1次翻转的情况，
然后根据最后一块转的颜色A[-1]是不是W可以确定最终翻转的是否符合条件。这样就完成了 翻转成WWWW...WWW的递推。

翻转成BBBB...BBB的过程同理，然后在翻转过程中记录下翻转的砖块位置，即可得出答案。
'''
t=int(input())
def rev(A,i):
    A[i]= 'B'if  A[i]=='W'else 'W'
    A[i+1]= 'B'if  A[i+1]=='W'else 'W'
def f(c):
    r=[]
    A1=A[::]
    for i in range(len(A)-1):
        if A1[i]!=c: 
            r.append(i+1)
            rev(A1,i)
    # print(A1)
    if A1[-1]==c: return r
    else: return []
while t:
    b=int(input())
    A=list(input())
    n=len(A)
    if len(set(A))==1: print(0)
    else:
        r=f('B') or f('W')
        if r:
            print(len(r))
            for x in r: print(x,end=' ')
            print()
        else:
            print(-1)
    t-=1