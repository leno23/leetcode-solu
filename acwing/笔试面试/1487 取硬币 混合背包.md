1487. 取硬币


现在有 n1+n2�1+�2 种面值的硬币，其中前 n1�1 种为普通币，可以取任意枚，后 n2�2 种为纪念币，每种最多只能取 11 枚，每种硬币有一个面值，问能用多少种方法拼出 m� 的面值？

#### 输入格式

第一行包含三个整数 n1,n2,m�1,�2,�，分别表示普通币种类数，纪念币种类数和目标面值；

第二行 n1�1 个整数，第 i� 种普通币的面值 a[i]�[�]。保证 a[i]�[�] 为严格升序；

第三行 n2�2 个整数，第 i� 种纪念币的面试 b[i]�[�]。保证 b[i]�[�] 为严格升序。

#### 输出格式

共一行，包含一个整数 x�，表示方法总数对 109+7109+7 取模后的结果。

注意，不要忘记取模。

#### 数据范围

对于 30%30% 的数据，保证 1≤n1+n2≤10,1≤m≤100,1≤a[i]≤100,1≤b[i]≤1001≤�1+�2≤10,1≤�≤100,1≤�[�]≤100,1≤�[�]≤100。  
对于 100%100% 的数据，保证 1≤n1+n2≤100,1≤m≤100000,1≤a[i]≤100000,1≤b[i]≤1000001≤�1+�2≤100,1≤�≤100000,1≤�[�]≤100000,1≤�[�]≤100000。

#### 输入样例：

```
3 1 5
1 2 3
1
```

#### 输出样例：

```
9
```

#### 样例解释

(x) 代表面值为x的普通币，[x]代表面值为x的纪念币，样例所有方法数如下：

```
(1)(1)(1)(1)(1)
(1)(1)(1)(2)
(1)(1)(3)
(1)(2)(2)
(2)(3)
(1)(1)(1)(1)[1]
(1)(1)[1](2)
(1)[1](3)
[1](2)(2)
```

```py
n1,n2,m=[int(x) for x in input().split()]
A1=[int(x) for x in input().split()]
A2=[int(x) for x in input().split()]
f=[0]*(m+1)
f[0]=1
M=10**9+7
# 完全背包+01背包
# 完全背包正序遍历
for x in A1:
    for j in range(x,m+1):
        f[j]=(f[j]+f[j-x])%M
        

# 01背包逆序遍历
for x in A2:
    for j in range(m,x-1,-1):
        f[j]=(f[j]+f[j-x])%M
print(f[m])