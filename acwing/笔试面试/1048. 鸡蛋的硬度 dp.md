1048. 鸡蛋的硬度

最近XX公司举办了一个奇怪的比赛：鸡蛋硬度之王争霸赛。

参赛者是来自世界各地的母鸡，比赛的内容是看谁下的蛋最硬，更奇怪的是XX公司并不使用什么精密仪器来测量蛋的硬度，他们采用了一种最老土的办法–从高度扔鸡蛋–来测试鸡蛋的硬度，如果一次母鸡下的蛋从高楼的第a层摔下来没摔破，但是从a+1层摔下来时摔破了，那么就说这只母鸡的鸡蛋的硬度是a。

你当然可以找出各种理由说明这种方法不科学，比如同一只母鸡下的蛋硬度可能不一样等等，但是这不影响XX公司的争霸赛，因为他们只是为了吸引大家的眼球，一个个鸡蛋从100 层的高楼上掉下来的时候，这情景还是能吸引很多人驻足观看的，当然，XX公司也绝不会忘记在高楼上挂一条幅，写上“XX公司”的字样–这比赛不过是XX公司的一个另类广告而已。

勤于思考的小A总是能从一件事情中发现一个数学问题，这件事也不例外。

“假如有很多同样硬度的鸡蛋，那么我可以用二分的办法用最少的次数测出鸡蛋的硬度”，小A对自己的这个结论感到很满意，不过很快麻烦来了，“但是，假如我的鸡蛋不够用呢，比如我只有1个鸡蛋，那么我就不得不从第1层楼开始一层一层的扔，最坏情况下我要扔100次。如果有2个鸡蛋，那么就从2层楼开始的地方扔……等等，不对，好像应该从1/3的地方开始扔才对，嗯，好像也不一定啊……3个鸡蛋怎么办，4个，5个，更多呢……”，和往常一样，小A又陷入了一个思维僵局，与其说他是勤于思考，不如说他是喜欢自找麻烦。

好吧，既然麻烦来了，就得有人去解决，小A的麻烦就靠你来解决了。

#### 输入格式

输入包括多组数据，每组数据一行，包含两个正整数 n� 和 m�，其中 n� 表示楼的高度，m� 表示你现在拥有的鸡蛋个数，这些鸡蛋硬度相同（即它们从同样高的地方掉下来要么都摔碎要么都不碎），并且小于等于 n�。

你可以假定硬度为 x� 的鸡蛋从高度小于等于 x� 的地方摔无论如何都不会碎（没摔碎的鸡蛋可以继续使用），而只要从比 x� 高的地方扔必然会碎。

对每组输入数据，你可以假定鸡蛋的硬度在 00 至 n� 之间，即在 n+1�+1 层扔鸡蛋一定会碎。

#### 输出格式

对于每一组输入，输出一个整数，表示使用最优策略在最坏情况下所需要的扔鸡蛋次数。

#### 数据范围

1≤n≤1001≤�≤100,  
1≤m≤101≤�≤10

#### 输入样例：

```
100 1
100 2
```

#### 输出样例：

```
100
14
```

#### 样例解释

最优策略指在最坏情况下所需要的扔鸡蛋次数最少的策略。

如果只有一个鸡蛋，你只能从第一层开始扔，在最坏的情况下，鸡蛋的硬度是100，所以需要扔100次。如果采用其他策略，你可能无法测出鸡蛋的硬度(比如你第一次在第二层的地方扔,结果碎了,这时你不能确定硬度是0还是1)，即在最坏情况下你需要扔无限次，所以第一组数据的答案是100。



```py
class Solution:
    def superEggDrop(self, k: int, n: int) -> int:
        # 对搜索过程中状态的结构进行记忆化
        memo ={}
        # dp(k,n)使用k个鸡蛋，在n个楼层中找到f的最少步数
        def dp(k,n):
            # 由于求最大值，所以初始化一个最大值
            ans=10**9
            if (k,n) in memo: return memo[(k,n)]
            # 只有一层楼，f只能是0
            if n==0: ans=0
            # 一个鸡蛋话，只能从第1层开始一层一层向上尝试，一共尝试n次
            elif k==1: ans=n
            else:
                '''
                k个鸡蛋，n层楼 朴素方法，将一个鸡蛋一次从1 2 3... 扔下
                从第i层楼扔下，会有两种情况:
                - 如果碎了,鸡蛋数-1,f还需要在第1~i-1层之间尝试,楼层数为i-1,次数为dp(k-1,i-1)
                - 如果没有碎，鸡蛋数不变,f需要在第i+1~n之间尝试，楼层数为n-i,次数为dp(k,n-i)
                要求最坏情况下的最小次数，就需要取 max(dp(k-1,i-1),dp(k,n-m))
                然后，和最终的ans取较小值，另外再加上这一次扔鸡蛋使用的次数
                ans = min(ans,max(dp(k-1,i-1),dp(k,n-m)) + 1)
                for i in range(1,n+1):
                    ans=min(max(dp(k-1,i-1),dp(k,n-i)))
                这样的解法时间复杂度位k*n^2 超时
                可以思考，对于dp(k,n)函数，随着楼层n的增加，需要尝试的次数也增加
                故，随着扔鸡蛋楼层i的增加, dp(k-1,i-1) 是递增的 dp(k,n-i) 是递减的 
                又，在第1层扔鸡蛋时，没有碎之后需要尝试的次数 要 比碎了之后要尝试的次数多，
                所以，随着i增加  dp(k-1,i-1)  dp(k,n-i)两个函数会有交点，
                而这个交点正是，他们最大值的最小值

                随着i增加，根据鸡蛋没有碎后尝试的次数dp(k,n-i)是否小于 鸡蛋碎了后尝试的次数dp(k-1,i-1) 可以产生以下序列
                0 0 0 0 1 1 1 1
                其中，第一个1对应的i，即所求的楼层，01序列使用二分进行查找
                '''
                l,r=1,n
                while l<r:
                    mid=l+r>>1
                    # 鸡蛋在第mid层碎了，还需要尝试的次数
                    t1=dp(k-1,mid-1)
                    # 鸡蛋在第mid层没有碎，还需要尝试的次数
                    t2=dp(k,n-mid)
                    if t1<t2:
                        l=mid+1
                    else:
                        r=mid
                ans = min(ans,max(dp(k-1,l-1),dp(k,n-l)) + 1)
            memo[(k,n)]=ans
            return ans
        return dp(k,n)

                    