1490. 最长上升子串


给出一个长度为 n� 的由正整数构成的序列，你需要从中删除一个正整数，很显然你有很多种删除方式，你需要对删除这个正整数以后的序列求其最长上升子串，请问在所有删除方案中，最长的上升子串长度是多少。

这里给出最长上升子串的定义：即对于序列中**连续**的若干个正整数，满足 ai+1>ai��+1>��，则称这连续的若干个整数构成的子串为上升子串，在所有的上升子串中，长度最长的称为最长上升子串。

#### 输入格式

输入第一行仅包含一个正整数 n�，表示给出的序列的长度。

接下来一行有 n� 个正整数，即这个序列，中间用空格隔开。

#### 输出格式

输出仅包含一个正整数，即删除一个数字之后的最长上升子串长度。

#### 数据范围

1≤n≤1051≤�≤105,  
1≤ai≤1051≤��≤105

#### 输入样例：

```
5
2 1 3 2 5
```

#### 输出样例：

```
3
```


```py
n=int(input())
a=[0]*(n+2)

'''
思路：
首先，考虑暴力法
需要枚举每个可能删除的数字，之后使用双指针统计最长上升子串的长度 时间复杂度为O(n^2) 
在当前10^5数据量下 会超时，所以这个方法放弃

动态规划思路
先初始化以每个位置数字为开头和结尾的最长上升子串的长度 f[i] g[i]

对于a[i],是否值得删除取决于 他前后数字的大小关系
记 f[i-1]为以i-1结尾的最长上升子串,f[i+1]为以i+1开头的最长上升子串
如果 a[i-1]<a[i+1]，删除之后,以a[i-1]结尾的最长子串 可以和 以a[i+1]开头的最长子串进行拼接,对最终的结果会有贡献,
否则，结果在f[i-1]和g[i+1]中取较大值

'''



f=[0]*(n+2)
g=[0]*(n+2)
r=[int(x) for x in input().split()]
# 输入数据时，向右偏移一位可以避免不必要的边界判断
for i in range(1,n+1):
    a[i]=r[i-1]

# f[i]以a[i]结尾的最长上升子串的长度
# 如果a[i]>a[i-1] 那么 f[i]就可以在f[i-1]的基础上+1，即f[i]=f[i-1]+1
for i in range(1,n+1):
    if a[i]>a[i-1]: f[i]=f[i-1]+1
    else: f[i]=1
    
for i in range(n,0,-1):
    # print(i)
    if a[i]<a[i+1]: g[i]=g[i+1]+1
    else: g[i]=1
res =0
for i in range(1,n+1):
    # a[i-1] >=a[i+1] 这个数字不需要删除,但是f[i-1] g[i+1]中可能存在更大值，需要更新答案
    if a[i-1]>=a[i+1]: res =  max(res,f[i-1],g[i+1])
    else: res = max(res, f[i-1]+g[i+1])

print(res)