4655. 重新排序


给定一个数组 AA 和一些查询 Li,RiLi,Ri，求数组中第 LiLi 至第 RiRi 个元素之和。

小蓝觉得这个问题很无聊，于是他想重新排列一下数组，使得最终每个查询结果的和尽可能地大。

小蓝想知道相比原数组，所有查询结果的总和最多可以增加多少?

#### 输入格式

输入第一行包含一个整数 nn。

第二行包含 nn 个整数 A1,A2,⋅⋅⋅,AnA1,A2,···,An，相邻两个整数之间用一个空格分隔。

第三行包含一个整数 mm 表示查询的数目。

接下来 mm 行，每行包含两个整数 Li、RiLi、Ri，相邻两个整数之间用一个空格分隔。

#### 输出格式

输出一行包含一个整数表示答案。

#### 数据范围

对于 30%30% 的评测用例，n,m≤50n,m≤50；  
对于 50%50% 的评测用例，n,m≤500n,m≤500；  
对于 70%70% 的评测用例，n,m≤5000n,m≤5000；  
对于所有评测用例，1≤n,m≤1051≤n,m≤105，1≤Ai≤1061≤Ai≤106，1≤Li≤Ri≤n1≤Li≤Ri≤n。

#### 输入样例：

```
5
1 2 3 4 5
2
1 3
2 5
```

#### 输出样例：

```
4
```

#### 样例解释

原来的和为 6+14=206+14=20，重新排列为 (1,4,5,2,3)(1,4,5,2,3) 后和为 10+14=2410+14=24，增加了 44。


```py
'''
对于一个数组a, 有10^6量级的询问 A1 A2,每次询问求第A1至A2之间的数字的和

这样的问题，如果朴素方法求解，每次的操作复杂度为O(n),如果询问个数是10^6量级,则整体复杂度为 O(10^6 * n)，会超时

所以，可以换个角度使用差分思想，或者上下车思想 
将原数组类比成一辆车，某个询问类比成 一个人在A1位置上车，在A2+1位置下车。
那么，数组中的a[i]代表时刻i时车上的人数变化
原问题变为 在若干次上下车之后，车上每个时刻的人数
这样，将原数组求前缀和，即可得到某个时刻车上的人数。

所以，对于原问题，可以这样求解
初始化一个s=[0]*(n+1)
对于每次询问A1 A2, 将s[A1]+=1,s[A2+1]-=1 表示一个人的上下车动作
然后，求s的前缀和数组pre,pre数字即是操作之后的数组,pre[i]代表位置i的数字加了多少次

最后，sum=pre[0]*a[0]+pre[1]*a[1]+...+pre[i]*a[i] 即是总和
'''

# 差分 贪心 排序不等式

n=int(input())
w=[int(x) for x in input().split()]

s=[0]*(n+1)
m=int(input())
# 差分求每个位置的数字加了多少次
while m:
    l,r=[int(x) for x in input().split()]
    s[l-1]+=1
    s[r]-=1
    m-=1
for i in range(n): s[i+1] += s[i]
# 根据每个位置加的次数，求出重排数组之前的总和
sum1=0
for i in range(n):
    sum1 += s[i]*w[i]
    
# ai代表每个位置数字加了多少次，bi代表每个位置的数字，
# 则问题变为对于a1*b1+a2*b2+...+ai*bi,什么时候可以取最大值？
# 答：只有两个序列升序，才可以求到最大值
w.sort(reverse=True)
s.sort(reverse=True)

sum2=0
for i in range(n):
    sum2 += s[i]*w[i]
    
print(sum2-sum1)
```