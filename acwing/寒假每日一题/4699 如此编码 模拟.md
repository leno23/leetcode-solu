4699. 如此编码


某次测验后，顿顿老师在黑板上留下了一串数字 2333323333 便飘然而去。

凝望着这个神秘数字，小 PP 同学不禁陷入了沉思……

已知某次测验包含 nn 道单项选择题，其中第 ii 题（1≤i≤n1≤i≤n）有 aiai 个选项，正确选项为 bibi，满足 ai≥2ai≥2 且 0≤bi<ai0≤bi<ai。

比如说，ai=4ai=4 表示第 ii 题有 44 个选项，此时正确选项 bibi 的取值一定是 00、11、22、33 其中之一。

顿顿老师设计了如下方式对正确答案进行编码，使得仅用一个整数 mm 便可表示 b1,b2,⋯,bnb1,b2,⋯,bn。

首先定义一个辅助数组 cici，表示数组 aiai 的前缀乘积。

当 1≤i≤n1≤i≤n 时，满足：

ci=a1×a2×⋯×aici=a1×a2×⋯×ai

特别地，定义 c0=1c0=1。

于是 mm 便可按照如下公式算出：

m=∑ni=1ci−1×bi=c0×b1+c1×b2+⋯+cn−1×bnm=∑i=1nci−1×bi=c0×b1+c1×b2+⋯+cn−1×bn

易知，0≤m<cn0≤m<cn，最小值和最大值分别当 bibi 全部为 00 和 bi=ai−1bi=ai−1 时取得。

试帮助小 PP 同学，把测验的正确答案 b1,b2,⋯,bnb1,b2,⋯,bn 从顿顿老师留下的神秘整数 mm 中恢复出来。

#### 输入格式

输入共两行。

第一行包含用空格分隔的两个整数 nn 和 mm，分别表示题目数量和顿顿老师的神秘数字。

第二行包含用空格分隔的 nn 个整数 a1,a2,⋯,ana1,a2,⋯,an，依次表示每道选择题的选项数目。

#### 输出格式

输出仅一行，包含用空格分隔的 nn 个整数 b1,b2,⋯,bnb1,b2,⋯,bn，依次表示每道选择题的正确选项。

#### 数据范围

50%50% 的测试数据满足：aiai 全部等于 22，即每道题均只有两个选项，此时 ci=2ici=2i；  
全部的测试数据满足：1≤n≤201≤n≤20，ai≥2ai≥2 且 cn≤109cn≤109（根据题目描述中的定义 cncn 表示全部 aiai 的乘积）。

#### 输入样例1：

```
15 32767
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
```

#### 输出样例1：

```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```

#### 输入样例2：

```
4 0
2 3 2 5
```

#### 输出样例2：

```
0 0 0 0
```

#### 输入样例3：

```
7 23333
3 5 20 10 4 3 10
```

#### 输出样例3：

```
2 2 15 7 3 1 0
```

#### 样例3解释

![QQ截图20220930112511.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5edd9445df76444a8d938f2b8f20a7e3~tplv-k3u1fbpfcp-zoom-1.image)

#### 提示

对任意的 1≤j≤n1≤j≤n，因为 cj+1,cj+2,⋯cj+1,cj+2,⋯ 均为 cjcj 的倍数，所以 mm 除以 cjcj 的余数具有如下性质：

m % cj=∑i=1jci−1×bim % cj=∑i=1jci−1×bi

其中 %% 表示取余运算。

令 jj 取不同的值，则有如下等式：

m % c1m % c2m % c3=c0×b1=c0×b1+c1×b2=c0×b1+c1×b2+c2×b3⋯

```py
n,m=[int(x) for x in input().split()]
a=[int(x) for x in input().split()]
c=[1]
for x in a:
    c.append(c[-1]*x)

pre=0
for i in range(n):
    bi=(m%c[i+1]-pre)//c[i]
    print(bi,end=' ')
    pre += c[i]*bi
```