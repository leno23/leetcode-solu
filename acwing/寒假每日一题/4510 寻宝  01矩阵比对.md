4510. 寻宝！大冒险！

暑假要到了。

可惜由于种种原因，小 P� 原本的出游计划取消。

失望的小 P� 只能留在西西艾弗岛上度过一个略显单调的假期……直到……

某天，小 P� 获得了一张神秘的藏宝图。

西西艾弗岛上种有 n� 棵树，这些树的具体位置记录在一张绿化图上。

简单地说，西西艾弗岛绿化图可以视作一个大小为 (L+1)×(L+1)(�+1)×(�+1) 的 0101 矩阵 A�，地图左下角（坐标 (0,0)(0,0)）和右上角（坐标 (L,L)(�,�)）分别对应 A[0][0]�[0][0] 和 A[L][L]�[�][�]。

其中 A[i][j]=1�[�][�]=1 表示坐标 (i,j)(�,�) 处种有一棵树，A[i][j]=0�[�][�]=0 则表示坐标 (i,j)(�,�) 处没有树。

换言之，矩阵 A� 中有且仅有的 n� 个 11 展示了西西艾弗岛上 n� 棵树的具体位置。

传说，大冒险家顿顿的宝藏就埋藏在某棵树下。

并且，顿顿还从西西艾弗岛的绿化图上剪下了一小块，制作成藏宝图指示其位置。

具体来说，藏宝图可以看作一个大小为 (S+1)×(S+1)(�+1)×(�+1) 的 0101 矩阵 B�（S� 远小于 L�），对应着 A� 中的某一部分。

理论上，绿化图 A� 中存在着一处坐标 (x,y)(�,�)（0≤x,y≤L−S0≤�,�≤�−�）与藏宝图 B� 左下角 (0,0)(0,0) 相对应，即满足：

对 B� 上任意一处坐标 (i,j)(�,�)（0≤i,j≤S0≤�,�≤�），都有 A[x+i][y+j]=B[i][j]�[�+�][�+�]=�[�][�]。

当上述条件满足时，我们就认为藏宝图 B� 对应着绿化图 A� 中左下角为 (x,y)(�,�)、右上角为 (x+S,y+S)(�+�,�+�) 的区域。

实际上，考虑到藏宝图仅描绘了很小的一个范围，满足上述条件的坐标 (x,y)(�,�) 很可能存在多个。

请结合西西艾弗岛绿化图中 n� 棵树的位置，以及小 P� 手中的藏宝图，判断绿化图中有多少处坐标满足条件。

**特别地，藏宝图左下角位置一定是一棵树，即 A[x][y]=B[0][0]=1�[�][�]=�[0][0]=1，表示了宝藏埋藏的位置。**

#### 输入格式

输入的第一行包含空格分隔的三个正整数 n�、L� 和 S�，分别表示西西艾弗岛上树的棵数、绿化图和藏宝图的大小。

由于绿化图尺寸过大，输入数据中仅包含 n� 棵树的坐标而非完整的地图；即接下来 n� 行每行包含空格分隔的两个整数 x� 和 y�，表示一棵树的坐标，满足 0≤x,y≤L0≤�,�≤� 且同一坐标不会重复出现。

最后 (S+1)(�+1) 行输入小 P� 手中完整的藏宝图，其中第 i� 行（0≤i≤S0≤�≤�）包含空格分隔的 (S+1)(�+1) 个 00 和 11，表示 B[S−i][0]⋯B[S−i][S]�[�−�][0]⋯�[�−�][�]。

**需要注意**，最先输入的是 B[S][0]⋯B[S][S]�[�][0]⋯�[�][�] 一行，B[0][0]⋯B[0][S]�[0][0]⋯�[0][�] 一行最后输入。

#### 输出格式

输出一个整数，表示绿化图中有多少处坐标可以与藏宝图左下角对应，即可能埋藏着顿顿的宝藏。

#### 数据范围

40%40% 的测试数据满足：L≤50�≤50；  
70%70% 的测试数据满足：L≤2000�≤2000；  
全部的测试数据满足：n≤1000�≤1000、L≤109�≤109 且 S≤50�≤50。

#### 输入样例1：

```
5 100 2
0 0
1 1
2 2
3 3
4 4
0 0 1
0 1 0
1 0 0
```

#### 输出样例1：

```
3
```

#### 样例1解释

绿化图上 (0,0)(0,0)、(1,1)(1,1) 和 (2,2)(2,2) 三处均可能埋有宝藏。

#### 输入样例2：

```
5 4 2
0 0
1 1
2 2
3 3
4 4
0 0 0
0 1 0
1 0 0
```

#### 输出样例2：

```
0
```

#### 样例2解释

如果将藏宝图左下角与绿化图 (3,3)(3,3) 处对应，则藏宝图右上角会超出绿化图边界，对应不成功。
```py
n,m,k=[int(x) for x in input().split()]
r=0
A=[]
for i in range(n):
    A.append([int(x) for x in input().split()])
B=[[0]*(k+1) for i in range(k+1)]
tc=0
for i in range(k,-1,-1):
    t=[int(x) for x in input().split()]
    for j in range(k+1):
        tc += t[j]
        B[i][j]=t[j]
# 遍历所有树的位置，看是否满足条件
for i in range(n):
    # 绿化园中一棵树的位置
    sx,sy=A[i]
    # 将藏宝图左下角放到sx,sy处，能否放下，放不下的话跳过
    if sx+k>m or sy+k>m: continue
    # 绿化园中以sx,sy为左下角，大小为藏宝图宽高的区域中，树的个数
    
    # 比对，以绿化园中以sx,sy为左下角，藏宝图大小的区域 和 藏宝图 这两个矩形是否一致
    # 遍历绿化园中所有树，看是否都在藏宝图中，在藏宝图中的有几个
    cnt=0
    ok=1
    for j in range(n): 
        x,y=A[j]
        if x>=sx and x-sx <=k and y>=sy and y-sy<=k:
            # 绿化园中sx,sy位置有树的位置，在藏宝图对应位置没有树，不对应，
            if not B[x-sx][y-sy]: 
                ok=0
                break
            # 绿化园中为1的地方，藏宝图中对应位置也为1
            else: cnt+=1
        # 当前树的位置，没有出现在藏宝图位置中，跳过
    # 矩阵A和矩阵B,A中每个为1的                                                                           位置，B对应位置也为1，而且A中1的个数=B中1的个数，则两个矩阵相同
    if ok and cnt==tc: r+=1
print(r)
            