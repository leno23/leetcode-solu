285. 没有上司的舞会

Ural 大学有 N� 名职员，编号为 1∼N1∼�。

他们的关系就像一棵以校长为根的树，父节点就是子节点的直接上司。

每个职员有一个快乐指数，用整数 Hi�� 给出，其中 1≤i≤N1≤�≤�。

现在要召开一场周年庆宴会，不过，没有职员愿意和直接上司一起参会。

在满足这个条件的前提下，主办方希望邀请一部分职员参会，使得所有参会职员的快乐指数总和最大，求这个最大值。

#### 输入格式

第一行一个整数 N�。

接下来 N� 行，第 i� 行表示 i� 号职员的快乐指数 Hi��。

接下来 N−1�−1 行，每行输入一对整数 L,K�,�，表示 K� 是 L� 的直接上司。

#### 输出格式

输出最大的快乐指数。

#### 数据范围

1≤N≤60001≤�≤6000,  
−128≤Hi≤127−128≤��≤127

#### 输入样例：

```
7
1
1
1
1
1
1
1
1 3
2 3
6 4
7 4
4 5
3 5
```

#### 输出样例：

```
5
```


```py
import sys
# python3最大栈深度只有999，此处需要调整
sys.setrecursionlimit(6010)

n=int(input())
happy = [0]*(n+1)
for i in range(n):
    happy[i+1]=int(input())
h,e,ne=[-1]*(n+1),[0]*(n+1),[0]*(n+1)
idx=0
# f[u][1/0] 以u为根节点的子树中，选或不选根节点的最大快乐指数
f=[[0,0] for i in range(n+1)]

has_fa = [0]*(n+1)
def add(a,b):
    global idx
    e[idx]=b
    ne[idx]=h[a]
    h[a]=idx
    idx+=1
for i in range(n-1):
    a,b=[int(x) for x in input().split()]
    add(b,a)
    has_fa[a]=1
root=1
while has_fa[root]: root+=1
def dfs(u):
    f[u][1]=happy[u]
    i=h[u]
    while i!= -1:
        j=e[i]
        # 处理子树的最大快乐指数
        dfs(j)
        f[u][0]+=max(f[j][0],f[j][1])
        f[u][1]+=f[j][0]
        i=ne[i]
dfs(root)
print(max(f[root][0],f[root][1]))


# 拓扑排序
from collections import deque
n=int(input())
happy = [0]*(n+1)
for i in range(n):
    happy[i+1]=int(input())

ing = [0]*(n+1)
fa=[0]*(n+1)
g=[[] for i in range(n+1)]
for i in range(n-1):
    a,b=[int(x) for x in input().split()]
    g[a].append(b)
    fa[a]=1
    ing[b]+=1
    
f=[[0,0]for i in range(n+1)]
root=1
for i in range(n):
    if not fa[i+1]: root=i+1

q=deque()
for i in range(n):
    if ing[i+1]==0: q.append(i+1)

while len(q):
    cur = q.popleft()
    f[cur][1]+=happy[cur]
    for to in g[cur]:
        ing[to]-=1
        f[to][1] += f[cur][0]
        f[to][0] += max(f[cur][0],f[cur][1])
        if ing[to]==0:
            q.append(to)

print(max(f[root][1],f[root][0]))
    

