1079. 叶子的颜色

-   [   题目](https://www.acwing.com/problem/content/description/1081/)
-   [   提交记录](https://www.acwing.com/problem/content/submission/1081/)
-   [   讨论](https://www.acwing.com/problem/content/discussion/index/1081/1/)
-   [   题解](https://www.acwing.com/problem/content/solution/1081/1/)
-   [   视频讲解](https://www.acwing.com/problem/content/video/1081/)

  


给一棵有 m� 个节点的无根树，你可以选择一个度数大于 11 的节点作为根，然后给一些节点（根、内部节点、叶子均可）着以黑色或白色。

你的着色方案应保证根节点到各叶子节点的简单路径上都至少包含一个有色节点，哪怕是这个叶子本身。

对于每个叶子节点 u�，定义 cu�� 为从根节点到 u� 的简单路径上最后一个有色节点的颜色。

给出每个 cu�� 的值，设计着色方案使得着色节点的个数尽量少。

#### 输入格式

第一行包括两个数 m,n�,�，依次表示节点总数和叶子个数，节点编号依次为 11 至 m�，其中编号 11 至 n� 是叶子。

接下来 n� 行每行一个 00 或 11 的数，其中 00 表示黑色，11 表示白色，依次为 c1,c2,…,cn�1,�2,…,�� 的值。

接下来 m−1�−1 行每行两个整数 a,b�,�，表示节点 a� 与 b� 有边相连。

#### 输出格式

输出仅一个数，表示着色节点数的最小值。

#### 数据范围

|  数据 |  1  |  2  |  3  |  4  |  5  |   6  |   7  |   8  |   9   |   10  |
| :-: | :-: | :-: | :-: | :-: | :-: | :--: | :--: | :--: | :---: | :---: |
|  M  |  10 |  50 | 100 | 200 | 400 | 1000 | 4000 | 8000 | 10000 | 10000 |
|  N  |  5  |  23 |  50 |  98 | 197 |  498 | 2044 | 4004 |  5021 |  4996 |

#### 输入样例：

```
5 3
0
1
0
1 4
2 5
4 5
3 5
```

#### 输出样例：

```
2
```

```py
def dfs(u, fa):
    # 枚举和u相连的所有点
    for v in paths[u]:
        # 如果v是父节点，跳过
        if v == fa:
            continue
        dfs(v, u)
        # 根据子树的染色情况，推整棵树的情况，所以需要后序遍历
        # 根节点染黑色的最小染色个数 可以由  子树染黑色-1 和 子树染白色的 的最小值转移
        # 根节点染白色的最小染色个数 可以由  子树染白色-1 和 子树染黑色的 的最小值转移
        f[u][1] += min(f[v][1] - 1, f[v][0])
        f[u][0] += min(f[v][0] - 1, f[v][1])

m, n = map(int, input().split())
# f[i][j]: 第i个节点涂颜色j时, 以i节点为根的子树中至少要涂的颜色的数量
f = [[1, 1] for i in range(m + 1)] 
for i in range(1, n + 1):
    tmp = int(input())
    f[i][tmp] = 1
    f[i][1 - tmp] = 1e9
# 邻接矩阵存边
paths = [[] for _ in range(m + 1)]
for i in range(m - 1):
    a, b = map(int, input().split())
    paths[a].append(b)
    paths[b].append(a)


# 经过推理发现根节点，由于叶子节点不变，所以无论以那个节点为根，得到的结果都一样
# 根节点染色的结果要比 不染色的结果 更优，所以在计算子树的最小染色个数时，不考虑根节点不染色的情况
# 任选一个非叶子节点为根，计算结果
dfs(n + 1, -1)
print(min(f[n + 1][0], f[n + 1][1]))

```