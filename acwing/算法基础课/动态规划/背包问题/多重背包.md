5. 多重背包问题 II

有 NN 种物品和一个容量是 VV 的背包。

第 ii 种物品最多有 sisi 件，每件体积是 vivi，价值是 wiwi。

求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。  
输出最大价值。

#### 输入格式

第一行两个整数，N，VN，V，用空格隔开，分别表示物品种数和背包容积。

接下来有 NN 行，每行三个整数 vi,wi,sivi,wi,si，用空格隔开，分别表示第 ii 种物品的体积、价值和数量。

#### 输出格式

输出一个整数，表示最大价值。

#### 数据范围

0<N≤10000<N≤1000  
0<V≤20000<V≤2000  
0<vi,wi,si≤20000<vi,wi,si≤2000

##### 提示：

本题考查多重背包的二进制优化方法。

#### 输入样例

```
4 5
1 2 3
2 4 1
3 4 3
4 5 2
```

#### 输出样例：

```
10
```


```py
#朴素解法 三重循环 1000数据量情况下 TLE
n,V = [int(x) for x in input().split()]

dp = [0 for i in range(V+1)]

for i in range(n):
    v,w,s=[int(x) for x in input().split()]
    j=V
    while j>=v:
        k=0
        while k<=s and j>= v*k:
            dp[j] = max(dp[j],dp[j-v*k]+k*w)
            k+=1
        j-=1
print(dp[V])



# 二进制优化  01背包扩展
'''

n个物品每个物品选或者不选，相当于将n划分为n个1，每个1选择不选，就变为一个01背包问题
1 1 1 1 1 1  

但是，这样的话，需要在01背包的基础上多一重循环枚举第j个物品中第k个选或者不选
复杂度为 1000*2000*2000=4* 10^9 会超时

会不会有另外一种划分方案，将n分为更少的份，根据每份选或者不选同样可以表示n?这时就考虑到二进制

例如n=8 二进制为 1000
那么,分为 1 2 4 1  这四个数，每个数字选或者不选时，可以徐成0~8范围中的所有数
因为8的最高位位权-1 = 7, 7 = 2^0+2^1+2^2,也就是 1 2 4,这些数可以组成 0~7范围的所有数。再加上剩余的8-7=1
这四个数可以表示0~8之间的所有数字 

一般的，对于n,从1 2 4 8...开始枚举求和 s,直到s>n  这个序列 1 2 4 ... x (s-n) 就是n对应的序列，他的个数有floor(log2(n)) + 1

这样一来，枚举第n个物品的选择情况时，只需要枚举log2(n)上取整次即可，时间复杂度也降低到
1000 * log2(2000) * 2000 = 1000 * 11 * 2000 = 10^7

'''
n,V = [int(x) for x in input().split()]
a=[]
# 将s个物品重新分组
for i in range(n):
    v,w,s=[int(x) for x in input().split()]
    # 第一组1个，后面为 2 4 8 ...
    k=1
    # 剩下的s还够不够分为k个一组
    while k<=s:
        # 总数中减去当前分出的数量
        s-=k
        a.append([v*k,w*k])        
        k*=2
    # 是否有剩余，有剩余的分为一组
    if s:
        a.append([v*s,w*s])

# 转化后，使用01背包解决
f = [0]*(V+1)
for x in a:
    j=V
    while j>=x[0]:
        f[j]=max(f[j],f[j-x[0]] + x[1])
        j-=1
print(f[V])





