846. 树的重心

给定一颗树，树中包含 nn 个结点（编号 1∼n1∼n）和 n−1n−1 条无向边。

请你找到树的重心，并输出将重心删除后，剩余各个连通块中点数的最大值。

重心定义：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。

#### 输入格式

第一行包含整数 nn，表示树的结点数。

接下来 n−1n−1 行，每行包含两个整数 aa 和 bb，表示点 aa 和点 bb 之间存在一条边。

#### 输出格式

输出一个整数 mm，表示将重心删除后，剩余各个连通块中点数的最大值。

#### 数据范围

1≤n≤1051≤n≤105

#### 输入样例

```
9
1 2
1 7
1 4
2 8
2 5
4 3
3 9
4 6
```

#### 输出样例：

```
4
```
```py
n=int(input())
m=n*2

# 建图，每个节点对应一个单链表
h=[-1]*(n+1)
e,ne=[0]*m,[0]*m

# 根据节点值去重
st=[0]*(n+1)

idx=0
ans =n
def add(a,b):
    global idx
    e[idx]=b
    ne[idx]=h[a]
    h[a]=idx
    idx+=1

# 去掉节点u之后联通块的最大值
def dfs(u):
    global ans
    st[u]=1
    res=0
    sm=1
    # 从链表头指针开始搜索
    i=h[u]
    while i!=-1:
        # 获取到节点值
        j=e[i]
        # 防止向上搜索
        if not st[j]:
            # 子树节点个数
            s=dfs(j)
            # 更新最大联通块节点个数
            res = max(res,s)
            sm+=s
        i=ne[i]
    # 去掉当前节点后，上面部分的连通块的节点个数 更新最大值
    res=max(res,n-sm)
    # 从每个节点最大联通块节点个数中 取最小值
    ans = min(ans,res)
    # 维护每个子树的节点个数
    return sm

for i in range(n-1):
    a,b=[int(x) for x in input().split()]
    add(a,b)
    add(b,a)

# 从第一个节点开始搜索
dfs(1)
print(ans)