
858. Prim算法求最小生成树

给定一个 n� 个点 m� 条边的无向图，图中可能存在重边和自环，边权可能为负数。

求最小生成树的树边权重之和，如果最小生成树不存在则输出 `impossible`。

给定一张边带权的无向图 G=(V,E)�=(�,�)，其中 V� 表示图中点的集合，E� 表示图中边的集合，n=|V|�=|�|，m=|E|�=|�|。

由 V� 中的全部 n� 个顶点和 E� 中 n−1�−1 条边构成的无向连通子图被称为 G� 的一棵生成树，其中边的权值之和最小的生成树被称为无向图 G� 的最小生成树。

#### 输入格式

第一行包含两个整数 n� 和 m�。

接下来 m� 行，每行包含三个整数 u,v,w�,�,�，表示点 u� 和点 v� 之间存在一条权值为 w� 的边。

#### 输出格式

共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出 `impossible`。

#### 数据范围

1≤n≤5001≤�≤500,  
1≤m≤1051≤�≤105,  
图中涉及边的边权的绝对值均不超过 1000010000。

#### 输入样例：

```
4 5
1 2 1
1 3 2
1 4 3
2 3 2
3 4 4
```

#### 输出样例：

```
6
```


```py
# 最小生成树: 在n个村庄,他们之间的距离不一样.现在要修路,使得他们之间连通,问如何修路使得成本最低
n,m=[int(x)for x in input().split()]

INF = 0x3f3f3f3f
g=[[INF]*(n+1) for i in range(n+1)]
for i in range(m):
    a,b,c=[int(x) for x in input().split()]
    g[b][a]= g[a][b]=min(g[a][b],c)
# dist[t] 点t到集合的距离
dist=[INF]*(n+1)
st=[0]*(n+1)
def prim():
    res =0
    for i in range(n):
        # 不在集合当中： 还没有确定最短距离
        # 不在集合当中的，距离集合最近的点
        # Prim中的集合：已经确定的生成树
        t=-1
        for j in range(1,n+1):
            # t需要在集合外
            # 如果还没有找到合适的点，或者j点到集合的距离比t点到集合的距离小，则更新t
            if not st[j] and (t==-1 or dist[t] > dist[j]): t=j
        # 集合外的点到 集合最近的距离是INF，证明图不是连通的
        if i and dist[t]==INF: return 'impossible'
        # 新加入的点对应的边，加入答案
        # 先累加再更新，防止负权值自环
        # 因为新加入t点,需要更新其他点到t的距离
        if i: res += dist[t]
        for j in range(1,n+1):
            dist[j]=min(dist[j],g[t][j])
        st[t]=1
    return res
print(prim())