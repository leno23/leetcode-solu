
847. 图中点的层次
给定一个 nn 个点 mm 条边的有向图，图中可能存在重边和自环。

所有边的长度都是 11，点的编号为 1∼n1∼n。

请你求出 11 号点到 nn 号点的最短距离，如果从 11 号点无法走到 nn 号点，输出 −1−1。

#### 输入格式

第一行包含两个整数 nn 和 mm。

接下来 mm 行，每行包含两个整数 aa 和 bb，表示存在一条从 aa 走到 bb 的长度为 11 的边。

#### 输出格式

输出一个整数，表示 11 号点到 nn 号点的最短距离。

#### 数据范围

1≤n,m≤1051≤n,m≤105

#### 输入样例

```
4 5
1 2
2 3
3 4
1 3
1 4
```

#### 输出样例

```
1
```

#### 输出格式

输出一个整数 mm，表示将重心删除后，剩余各个连通块中点数的最大值。

#### 数据范围

1≤n≤1051≤n≤105

#### 输入样例

```
9
1 2
1 7
1 4
2 8
2 5
4 3
3 9
4 6
```

#### 输出样例

```
4
```

```py
n,m=[int(x)for x in input().split()]

h,ne,e=[-1]*100010,[0]*100010,[0]*100010
idx=0
def add(a,b):
    global idx
    e[idx]=b
    ne[idx]=h[a]
    h[a]=idx
    idx+=1

# 模拟队列的数组，存储每个点距离1节点的最短距离
q,d=[0]*(n+1),[-1]*(n+1)
def bfs():
    # 数组模拟队列
    hh,tt=0,0
    # 从节点1开始走
    q[0]=1
    d[1]=0
    while hh<=tt:
        t=q[hh]
        hh+=1
        i=h[t]
        while i!=-1:
            j=e[i]
            if d[j]==-1:
                d[j]=d[t]+1
                tt+=1
                q[tt]=j
            i=ne[i]
    return d[n]
        
for i in range(m):
    a,b=[int(x)for x in input().split()]
    add(a,b)
print(bfs())
